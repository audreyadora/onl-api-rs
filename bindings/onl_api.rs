/* automatically generated by rust-bindgen 0.70.1 */

pub const AIM_CONFIG_INCLUDE_LOGGING: u32 = 1;
pub const AIM_CONFIG_PORTING_STDLIB: u32 = 1;
pub const AIM_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS: u32 = 1;
pub const AIM_CONFIG_LOG_MESSAGE_SIZE: u32 = 256;
pub const AIM_CONFIG_LOG_INCLUDE_LINUX_TIMESTAMP: u32 = 1;
pub const AIM_CONFIG_LOG_INCLUDE_ENV_VARIABLES: u32 = 1;
pub const AIM_CONFIG_PVS_INCLUDE_TTY: u32 = 1;
pub const AIM_CONFIG_LOG_INCLUDE_TTY_COLOR: u32 = 1;
pub const AIM_CONFIG_INCLUDE_MODULES_INIT: u32 = 0;
pub const AIM_CONFIG_INCLUDE_MODULES_DENIT: u32 = 0;
pub const AIM_CONFIG_INCLUDE_MAIN: u32 = 0;
pub const AIM_CONFIG_INCLUDE_ENV_ARGV: u32 = 0;
pub const AIM_CONFIG_ENV_ARGV_NAME: &[u8; 13] = b"AIM_ENV_ARGV\0";
pub const AIM_CONFIG_INCLUDE_VALGRIND: u32 = 0;
pub const AIM_CONFIG_INCLUDE_DAEMONIZE: u32 = 0;
pub const AIM_CONFIG_INCLUDE_PVS_SYSLOG: u32 = 0;
pub const AIM_CONFIG_PVS_SYSLOG_IDENT_DEFAULT: &[u8; 4] = b"AIM\0";
pub const AIM_CONFIG_INCLUDE_OS_POSIX: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201605;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 24;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _MEMORY_H: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const AIM_DATATYPE_ERROR: i32 = -1;
pub const AIM_DATATYPE_OK: u32 = 0;
pub const ONLP_CONFIG_INCLUDE_LOGGING: u32 = 1;
pub const ONLP_CONFIG_LOG_CUSTOM_BITS_DEFAULT: u32 = 0;
pub const ONLP_CONFIG_PORTING_STDLIB: u32 = 1;
pub const ONLP_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS: u32 = 1;
pub const ONLP_CONFIG_INCLUDE_UCLI: u32 = 0;
pub const ONLP_CONFIG_INCLUDE_PLATFORM_ERROR_CHECK: u32 = 1;
pub const ONLP_CONFIG_INCLUDE_SHLOCK_GLOBAL_INIT: u32 = 0;
pub const ONLP_CONFIG_INCLUDE_PLATFORM_STATIC: u32 = 0;
pub const ONLP_CONFIG_PLATFORM_STATIC: &[u8; 8] = b"unknown\0";
pub const ONLP_CONFIG_PLATFORM_FILENAME: &[u8; 18] = b"/etc/onl/platform\0";
pub const ONLP_CONFIG_INCLUDE_PLATFORM_OVERRIDES: u32 = 1;
pub const ONLP_CONFIG_CONFIGURATION_FILENAME: &[u8; 15] = b"/etc/onlp.conf\0";
pub const ONLP_CONFIG_CONFIGURATION_ENV: &[u8; 10] = b"ONLP_CONF\0";
pub const ONLP_CONFIG_INCLUDE_API_LOCK: u32 = 1;
pub const ONLP_CONFIG_API_LOCK_GLOBAL_SHARED: u32 = 1;
pub const ONLP_CONFIG_API_LOCK_TIMEOUT: u32 = 60000000;
pub const ONLP_CONFIG_INFO_STR_MAX: u32 = 64;
pub const ONLP_CONFIG_INCLUDE_THERMAL_THRESHOLDS: u32 = 0;
pub const ONLP_CONFIG_INCLUDE_API_PROFILING: u32 = 0;
pub const OFSET_AI: u32 = 0;
pub const OFSET_AO: u32 = 16;
pub const OFSET_DI: u32 = 32;
pub const OFSET_DO: u32 = 48;
pub const OFSET_CNT: u32 = 64;
pub const OFSET_MEM: u32 = 80;
pub const OFSET_ECU: u32 = 128;
pub const ECU_RESET: u32 = 0;
pub const ECU_ENABLEINT: u32 = 1;
pub const ECU_DISABLEINT: u32 = 2;
pub const ECU_CONNECT: u32 = 3;
pub const ECU_COMBINATION: u32 = 4;
pub const ECU_GENERALCOMMAND1: u32 = 5;
pub const ECU_GENERALCOMMAND2: u32 = 6;
pub const ECU_GENERALCOMMAND3: u32 = 7;
pub const ECU_GENERALCOMMAND4: u32 = 8;
pub const ECU_DELAYTIME: u32 = 9;
pub const ECU_EMERGENCY: u32 = 10;
pub const ECU_AIEMERGENCY: u32 = 16;
pub const ECU_AOEMERGENCY: u32 = 17;
pub const ECU_SRAMTEST: u32 = 18;
pub const ECU_SYNCBUS: u32 = 24;
pub const MEM_ALLRESET: u32 = 0;
pub const MEM_AITRANSFERTYPE: u32 = 1;
pub const MEM_AOTRANSFERTYPE: u32 = 2;
pub const MEM_AIWT: u32 = 3;
pub const MEM_AIRT: u32 = 4;
pub const MEM_AOWT: u32 = 5;
pub const MEM_AORT: u32 = 6;
pub const MEM_AICLEAR: u32 = 7;
pub const MEM_AOCLEAR: u32 = 8;
pub const MEM_AIMEMORYTYPE: u32 = 9;
pub const MEM_AOMEMORYTYPE: u32 = 10;
pub const MEM_AIFIFOREAD: u32 = 11;
pub const MEM_AOFIFOREAD: u32 = 12;
pub const MEM_AIFIFO1DEBUG: u32 = 13;
pub const MEM_AIFIFO2DEBUG: u32 = 14;
pub const MEM_DDRTEST: u32 = 15;
pub const MEM_AICOMPTYPE: u32 = 16;
pub const MEM_AICOMPDATA: u32 = 17;
pub const MEM_AITRGWP: u32 = 18;
pub const MEM_AITRGRP: u32 = 19;
pub const MEM_AIMAXWP: u32 = 20;
pub const MEM_AIATTACHEDDATA: u32 = 21;
pub const MEM_AISTOPTRGDATA: u32 = 22;
pub const MEM_AISWITCH: u32 = 24;
pub const MEM_AOCOMPTYPE: u32 = 32;
pub const MEM_AOCOMPDATA: u32 = 33;
pub const MEM_AOTRGWP: u32 = 34;
pub const MEM_AOTRGRP: u32 = 35;
pub const MEM_AOMAXRP: u32 = 36;
pub const MEM_AOATTACHEDDATA: u32 = 37;
pub const MEM_AOBANKRP: u32 = 38;
pub const AI_RESET: u32 = 0;
pub const AI_OPEN: u32 = 1;
pub const AI_CLOSE: u32 = 2;
pub const AI_CLOCK: u32 = 3;
pub const AI_SCANCLOCK: u32 = 4;
pub const AI_CHANNELS: u32 = 5;
pub const AI_SEQUENCE: u32 = 6;
pub const AI_METHOD: u32 = 7;
pub const AI_RANGE: u32 = 8;
pub const AI_BTSAMPLING: u32 = 9;
pub const AI_ATSAMPLING: u32 = 10;
pub const AI_REPEAT: u32 = 11;
pub const AI_CHANNELMODE: u32 = 12;
pub const AI_CHANNELGATE: u32 = 13;
pub const AI_ADJUSTMENT: u32 = 32;
pub const AI_EEPROM: u32 = 33;
pub const AI_LEVELTRGTYPE: u32 = 34;
pub const AI_LEVELTRGCHANNEL: u32 = 35;
pub const AI_LEVELTRGSTATE: u32 = 36;
pub const AI_LEVEL: u32 = 37;
pub const AI_COMPSAMPLING: u32 = 38;
pub const AI_COMPREPEAT: u32 = 39;
pub const AO_RESET: u32 = 0;
pub const AO_OPEN: u32 = 1;
pub const AO_CLOSE: u32 = 2;
pub const AO_CLOCK: u32 = 3;
pub const AO_CHANNELS: u32 = 5;
pub const AO_SEQUENCE: u32 = 6;
pub const AO_RANGE: u32 = 8;
pub const AO_BTSAMPLING: u32 = 9;
pub const AO_ATSAMPLING: u32 = 10;
pub const AO_REPEAT: u32 = 11;
pub const AO_CHANNELMODE: u32 = 12;
pub const AO_REPEATCOUNT: u32 = 13;
pub const AO_ADJUSTMENT: u32 = 32;
pub const AO_EEPROM: u32 = 33;
pub const AO_LEVELTRGTYPE: u32 = 34;
pub const AO_LEVELTRGCHANNEL: u32 = 35;
pub const AO_LEVELTRGSTATE: u32 = 36;
pub const AO_LEVEL: u32 = 37;
pub const AO_COMPSAMPLING: u32 = 38;
pub const AO_COMPREPEAT: u32 = 39;
pub const AO_EX1: u32 = 40;
pub const AO_EX2: u32 = 41;
pub const AO_EX3: u32 = 42;
pub const CNT_RESET: u32 = 0;
pub const CNT_OPEN: u32 = 1;
pub const CNT_CLOSE: u32 = 2;
pub const CNT_CLOCK: u32 = 3;
pub const CNT_MODE: u32 = 4;
pub const CNT_CURRENT: u32 = 5;
pub const CNT_LOAD: u32 = 6;
pub const CNT_COMPARISON: u32 = 7;
pub const CNT_EMERGENCY: u32 = 8;
pub const DI_RESET: u32 = 0;
pub const DI_EDGE: u32 = 1;
pub const DI_FILTER: u32 = 2;
pub const DI_DIRECTION: u32 = 3;
pub const DI_SERIAL: u32 = 4;
pub const DI_PARALLELL: u32 = 5;
pub const DO_RESET: u32 = 0;
pub const DO_CFG: u32 = 1;
pub const DO_SIGCFG: u32 = 2;
pub const DO_PLS: u32 = 3;
pub const DO_SERIAL: u32 = 4;
pub const DO_PARALLELL: u32 = 5;
pub const DO_SERIALCFG: u32 = 6;
pub const DO_PWM: u32 = 7;
pub const ONLPLIB_CONFIG_INCLUDE_LOGGING: u32 = 1;
pub const ONLPLIB_CONFIG_LOG_CUSTOM_BITS_DEFAULT: u32 = 0;
pub const ONLPLIB_CONFIG_PORTING_STDLIB: u32 = 1;
pub const ONLPLIB_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS: u32 = 1;
pub const ONLPLIB_CONFIG_INCLUDE_UCLI: u32 = 0;
pub const ONLPLIB_CONFIG_INCLUDE_I2C: u32 = 1;
pub const ONLPLIB_CONFIG_I2C_BLOCK_SIZE: u32 = 32;
pub const ONLPLIB_CONFIG_I2C_READ_RETRY_COUNT: u32 = 16;
pub const ONLPLIB_CONFIG_I2C_USE_CUSTOM_HEADER: u32 = 1;
pub const ONLPLIB_CONFIG_INCLUDE_I2C_SMBUS: u32 = 0;
pub const ONLP_OID_DESC_SIZE: u32 = 128;
pub const ONLP_OID_TABLE_SIZE: u32 = 128;
pub const SFF_CONFIG_INCLUDE_LOGGING: u32 = 1;
pub const SFF_CONFIG_LOG_CUSTOM_BITS_DEFAULT: u32 = 0;
pub const SFF_CONFIG_PORTING_STDLIB: u32 = 1;
pub const SFF_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS: u32 = 1;
pub const SFF_CONFIG_INCLUDE_UCLI: u32 = 0;
pub const SFF_CONFIG_INCLUDE_SFF_TOOL: u32 = 0;
pub const SFF_CONFIG_INCLUDE_EXT_CC_CHECK: u32 = 0;
pub const SFF_CONFIG_INCLUDE_DATABASE: u32 = 1;
pub const ONLP_THERMAL_CAPS_ALL: u32 = 15;
#[doc = " Configuration settings structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_config_settings_s {
    #[doc = " name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " value"]
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_config_settings_s"][::std::mem::size_of::<aim_config_settings_s>() - 16usize];
    ["Alignment of aim_config_settings_s"]
        [::std::mem::align_of::<aim_config_settings_s>() - 8usize];
    ["Offset of field: aim_config_settings_s::name"]
        [::std::mem::offset_of!(aim_config_settings_s, name) - 0usize];
    ["Offset of field: aim_config_settings_s::value"]
        [::std::mem::offset_of!(aim_config_settings_s, value) - 8usize];
};
#[doc = " Configuration settings structure."]
pub type aim_config_settings_t = aim_config_settings_s;
extern "C" {
    #[doc = " Configuration settings table. */\n/** aim_config_settings table."]
    pub static mut aim_config_settings: [aim_config_settings_t; 0usize];
}
extern "C" {
    #[doc = " @brief Lookup a configuration setting.\n @param setting The name of the configuration option to lookup."]
    pub fn aim_config_lookup(
        setting: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Show the compile-time configuration.\n @param pvs The output stream."]
    pub fn aim_config_show(pvs: *mut aim_pvs_s) -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_marker"][::std::mem::size_of::<_IO_marker>() - 24usize];
    ["Alignment of _IO_marker"][::std::mem::align_of::<_IO_marker>() - 8usize];
    ["Offset of field: _IO_marker::_next"][::std::mem::offset_of!(_IO_marker, _next) - 0usize];
    ["Offset of field: _IO_marker::_sbuf"][::std::mem::offset_of!(_IO_marker, _sbuf) - 8usize];
    ["Offset of field: _IO_marker::_pos"][::std::mem::offset_of!(_IO_marker, _pos) - 16usize];
};
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::__pad1"][::std::mem::offset_of!(_IO_FILE, __pad1) - 152usize];
    ["Offset of field: _IO_FILE::__pad2"][::std::mem::offset_of!(_IO_FILE, __pad2) - 160usize];
    ["Offset of field: _IO_FILE::__pad3"][::std::mem::offset_of!(_IO_FILE, __pad3) - 168usize];
    ["Offset of field: _IO_FILE::__pad4"][::std::mem::offset_of!(_IO_FILE, __pad4) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t___pthread_mutex_s"]
        [::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() - 40usize];
    ["Alignment of pthread_mutex_t___pthread_mutex_s"]
        [::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() - 8usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__count"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __count) - 4usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: pthread_mutex_t___pthread_mutex_s::__list"]
        [::std::mem::offset_of!(pthread_mutex_t___pthread_mutex_s, __list) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() - 48usize];
    ["Alignment of pthread_cond_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__lock"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __lock) - 0usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__futex"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __futex) - 4usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__total_seq"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __total_seq) - 8usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__wakeup_seq"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __wakeup_seq) - 16usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__woken_seq"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __woken_seq) - 24usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__mutex"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __mutex) - 32usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__nwaiters"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __nwaiters) - 40usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__broadcast_seq"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __broadcast_seq) - 44usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() - 56usize];
    ["Alignment of pthread_rwlock_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__lock"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __lock) - 0usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__nr_readers"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __nr_readers) - 4usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__readers_wakeup"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __readers_wakeup) - 8usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__writer_wakeup"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __writer_wakeup) - 12usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__nr_readers_queued"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __nr_readers_queued) - 16usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__nr_writers_queued"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __nr_writers_queued) - 20usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__writer"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __writer) - 24usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__shared"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __shared) - 28usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__rwelision"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __rwelision) - 32usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__pad1"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __pad1) - 33usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__pad2"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __pad2) - 40usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__flags"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __flags) - 48usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Sometimes we must pass va_lists as pointers to be shared\n between different functions processing (and updating) the same\n va_list.\n\n This is allowed in the C99 specification, but\n actually doing it becomes problematic when va_list is defined\n as an array, rather than a pointer, as taking the address of the local\n array is not equivalent to \"va_list*\". This has nothing to do with\n va_lists per se, but the way C handles arrays as parameters to functions.\n\n We get around this portability problem by defining a structure to\n contain the va_list, and pass a pointer to that structure\n instead.\n\n We could have defined a macro to create a va_list* from a va_list,\n but this would have to be configured by hand, and on architectures\n where va_list is a pointer, you would not see a warning or a bug\n to indicate you have introduced a portability problem for other\n architectures.\n\n If we always pass aim_va_list_t*, instead of va_list*, we will\n always get typechecking and portability for all platforms.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_va_list_s {
    #[doc = " The va_list structure"]
    pub val: va_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_va_list_s"][::std::mem::size_of::<aim_va_list_s>() - 24usize];
    ["Alignment of aim_va_list_s"][::std::mem::align_of::<aim_va_list_s>() - 8usize];
    ["Offset of field: aim_va_list_s::val"][::std::mem::offset_of!(aim_va_list_s, val) - 0usize];
};
#[doc = " Sometimes we must pass va_lists as pointers to be shared\n between different functions processing (and updating) the same\n va_list.\n\n This is allowed in the C99 specification, but\n actually doing it becomes problematic when va_list is defined\n as an array, rather than a pointer, as taking the address of the local\n array is not equivalent to \"va_list*\". This has nothing to do with\n va_lists per se, but the way C handles arrays as parameters to functions.\n\n We get around this portability problem by defining a structure to\n contain the va_list, and pass a pointer to that structure\n instead.\n\n We could have defined a macro to create a va_list* from a va_list,\n but this would have to be configured by hand, and on architectures\n where va_list is a pointer, you would not see a warning or a bug\n to indicate you have introduced a portability problem for other\n architectures.\n\n If we always pass aim_va_list_t*, instead of va_list*, we will\n always get typechecking and portability for all platforms.\n"]
pub type aim_va_list_t = aim_va_list_s;
#[doc = " Provides a common structure definition for facilitating\n polymorphic interfaces where appropriate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_object_s {
    #[doc = " Unique Object Identifier (String)\n\n Set this to a statically allocated string buffer\n in your own compilation unit.\n\n The ADDRESS of the string is what guarantees the uncoordinated\n uniqueness of your object id, not the CONTENTS of the string.\n\n The CONTENTS of the string are only for humans."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = " Optional Object Subtype.\n\n Set to whatever makes sense for your object."]
    pub subtype: ::std::os::raw::c_int,
    #[doc = " Object data pointer. Optional."]
    pub cookie: *mut ::std::os::raw::c_void,
    #[doc = " You can specify a destructor for your object."]
    pub destructor: ::std::option::Option<unsafe extern "C" fn(object: *mut aim_object_s)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_object_s"][::std::mem::size_of::<aim_object_s>() - 32usize];
    ["Alignment of aim_object_s"][::std::mem::align_of::<aim_object_s>() - 8usize];
    ["Offset of field: aim_object_s::id"][::std::mem::offset_of!(aim_object_s, id) - 0usize];
    ["Offset of field: aim_object_s::subtype"]
        [::std::mem::offset_of!(aim_object_s, subtype) - 8usize];
    ["Offset of field: aim_object_s::cookie"]
        [::std::mem::offset_of!(aim_object_s, cookie) - 16usize];
    ["Offset of field: aim_object_s::destructor"]
        [::std::mem::offset_of!(aim_object_s, destructor) - 24usize];
};
#[doc = " Provides a common structure definition for facilitating\n polymorphic interfaces where appropriate."]
pub type aim_object_t = aim_object_s;
#[doc = " Typedef for destructors."]
pub type aim_object_dtor = ::std::option::Option<unsafe extern "C" fn(arg1: *mut aim_object_t)>;
extern "C" {
    #[doc = " @brief Allocate an aim_object.\n @param size The size of the object.\n @param id The object id\n @param subtype The object subtype\n @param cookie The object cookie\n @param dtor The object destructor."]
    pub fn aim_object_create(
        size: ::std::os::raw::c_uint,
        id: *const ::std::os::raw::c_char,
        subtype: ::std::os::raw::c_int,
        cookie: *mut ::std::os::raw::c_void,
        dtor: aim_object_dtor,
    ) -> *mut aim_object_t;
}
extern "C" {
    #[doc = " @brief Destroy an aim_object.\n @param obj The object."]
    pub fn aim_object_destroy(obj: *mut aim_object_t);
}
#[doc = " Map a string to an integer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_map_si_t {
    #[doc = " String value"]
    pub s: *const ::std::os::raw::c_char,
    #[doc = " Integer value"]
    pub i: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_map_si_t"][::std::mem::size_of::<aim_map_si_t>() - 16usize];
    ["Alignment of aim_map_si_t"][::std::mem::align_of::<aim_map_si_t>() - 8usize];
    ["Offset of field: aim_map_si_t::s"][::std::mem::offset_of!(aim_map_si_t, s) - 0usize];
    ["Offset of field: aim_map_si_t::i"][::std::mem::offset_of!(aim_map_si_t, i) - 8usize];
};
extern "C" {
    #[doc = " @brief Map a string to an integer.\n @param [out] rv The mapped integer value.\n @param s The string to map.\n @param maps The map table.\n @param count The number of entries in the map table.\n\n @returns 1 if the mapping was successful.\n @returns 0 if the mapping failed.\n\n @note If count is 0, maps is assumed to be terminated with a null entry."]
    pub fn aim_map_si_s(
        rv: *mut ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
        maps: *mut aim_map_si_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Map an integer to a string.\n @param [out] rv The mapped string value.\n @param i The integer to map.\n @param maps The map table.\n @param count The number of entries in the map table.\n\n @returns 1 if the mapping was successful.\n @returns 0 if the mapping failed.\n\n @note If count is 0, maps is assumed to be terminated with a null entry."]
    pub fn aim_map_si_i(
        rv: *mut *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
        maps: *mut aim_map_si_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const aim_log_flag_e_AIM_LOG_FLAG_MSG: aim_log_flag_e = 0;
pub const aim_log_flag_e_AIM_LOG_FLAG_FATAL: aim_log_flag_e = 1;
pub const aim_log_flag_e_AIM_LOG_FLAG_ERROR: aim_log_flag_e = 2;
pub const aim_log_flag_e_AIM_LOG_FLAG_WARN: aim_log_flag_e = 3;
pub const aim_log_flag_e_AIM_LOG_FLAG_INFO: aim_log_flag_e = 4;
pub const aim_log_flag_e_AIM_LOG_FLAG_VERBOSE: aim_log_flag_e = 5;
pub const aim_log_flag_e_AIM_LOG_FLAG_TRACE: aim_log_flag_e = 6;
pub const aim_log_flag_e_AIM_LOG_FLAG_INTERNAL: aim_log_flag_e = 7;
pub const aim_log_flag_e_AIM_LOG_FLAG_BUG: aim_log_flag_e = 8;
pub const aim_log_flag_e_AIM_LOG_FLAG_FTRACE: aim_log_flag_e = 9;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_EMERG: aim_log_flag_e = 10;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_ALERT: aim_log_flag_e = 11;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_CRIT: aim_log_flag_e = 12;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_ERROR: aim_log_flag_e = 13;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_WARN: aim_log_flag_e = 14;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_NOTICE: aim_log_flag_e = 15;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_INFO: aim_log_flag_e = 16;
pub const aim_log_flag_e_AIM_LOG_FLAG_SYSLOG_DEBUG: aim_log_flag_e = 17;
pub const aim_log_flag_e_AIM_LOG_FLAG_LAST: aim_log_flag_e = 17;
pub const aim_log_flag_e_AIM_LOG_FLAG_COUNT: aim_log_flag_e = 18;
pub const aim_log_flag_e_AIM_LOG_FLAG_INVALID: aim_log_flag_e = -1;
#[doc = " aim_log_flag"]
pub type aim_log_flag_e = ::std::os::raw::c_int;
#[doc = " aim_log_flag"]
pub use self::aim_log_flag_e as aim_log_flag_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn aim_log_flag_name(e: aim_log_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn aim_log_flag_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut aim_log_flag_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn aim_log_flag_desc(e: aim_log_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " aim_log_flag_map table."]
    pub static mut aim_log_flag_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " aim_log_flag_desc_map table."]
    pub static mut aim_log_flag_desc_map: [aim_map_si_t; 0usize];
}
#[doc = " @brief Log function typedef, to be used by aim_logf_set.\n @param cookie To be passed to logging function.\n @param flag Associated log flag.\n @param str String to log."]
pub type aim_log_f = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        flag: aim_log_flag_t,
        str_: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " aim_pvs_t"]
pub type aim_pvs_t = aim_pvs_s;
#[doc = " All fundamental output vectors share this signature."]
pub type aim_vprint_f = ::std::option::Option<
    unsafe extern "C" fn(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This structure represents a fundamental output stream.\n All functions which produce output should be written to\n accept a pointer to this structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_pvs_s {
    #[doc = " AIM object."]
    pub object: aim_object_t,
    #[doc = " Description"]
    pub description: *mut ::std::os::raw::c_char,
    #[doc = " This is the vector that will eventually receive the output for\n this stream."]
    pub vprintf: aim_vprint_f,
    #[doc = " Any output stream can be enabled or disabled."]
    pub enabled: ::std::os::raw::c_int,
    #[doc = " Call counter"]
    pub counter: u32,
    #[doc = " Optional:\n returns whether this PVS can be considered a tty, where applicable"]
    pub isatty:
        ::std::option::Option<unsafe extern "C" fn(pvs: *mut aim_pvs_t) -> ::std::os::raw::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_pvs_s"][::std::mem::size_of::<aim_pvs_s>() - 64usize];
    ["Alignment of aim_pvs_s"][::std::mem::align_of::<aim_pvs_s>() - 8usize];
    ["Offset of field: aim_pvs_s::object"][::std::mem::offset_of!(aim_pvs_s, object) - 0usize];
    ["Offset of field: aim_pvs_s::description"]
        [::std::mem::offset_of!(aim_pvs_s, description) - 32usize];
    ["Offset of field: aim_pvs_s::vprintf"][::std::mem::offset_of!(aim_pvs_s, vprintf) - 40usize];
    ["Offset of field: aim_pvs_s::enabled"][::std::mem::offset_of!(aim_pvs_s, enabled) - 48usize];
    ["Offset of field: aim_pvs_s::counter"][::std::mem::offset_of!(aim_pvs_s, counter) - 52usize];
    ["Offset of field: aim_pvs_s::isatty"][::std::mem::offset_of!(aim_pvs_s, isatty) - 56usize];
};
extern "C" {
    #[doc = " Use this builtin PVS structure for output to stdout."]
    pub static mut aim_pvs_stdout: aim_pvs_t;
}
extern "C" {
    #[doc = " Use this builtin PVS structure for output to stderr."]
    pub static mut aim_pvs_stderr: aim_pvs_t;
}
extern "C" {
    #[doc = " Use this builtin PVS structure for discarding output."]
    pub static mut aim_pvs_none: aim_pvs_t;
}
extern "C" {
    #[doc = " @brief printf-style output to any PVS.\n @param pvs The PVS output stream.\n @param fmt The format string.\n @note This does not include custom datatype processing.\n @note Most clients should call aim_printf() instead."]
    pub fn aim_pvs_printf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief vprintf-style output to any PVS.\n @param pvs The PVS output stream.\n @param fmt The format string.\n @param vargs The format arguments.\n @note This does not include custom datatype processing.\n @note Most clients should call aim_vprintf() instead."]
    pub fn aim_pvs_vprintf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief vprintf-style output to any PVS.\n @param pvs The PVS output stream.\n @param fmt The format string.\n @param vargs The AIM variable argument structure.\n @note This does not include custom datatype processing.\n @note Most clients should call aim_avprintf() instead."]
    pub fn aim_pvs_avprintf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut aim_va_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable output on the given PVS.\n @param pvs The PVS output stream.\n @param enable Enable/Disable state.\n\n @note All output for the PVS will be silently discarded when\n the PVS is disabled."]
    pub fn aim_pvs_enable(
        pvs: *mut aim_pvs_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Destroy a PVS object.\n @param pvs The object to destroy."]
    pub fn aim_pvs_destroy(pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " @brief Determine whether a PVS is a tty.\n @param pvs The object to query.\n @returns 1 If the object is a tty.\n @returns 0 If the object is not a tty.\n @returns -1 If unknown."]
    pub fn aim_pvs_isatty(pvs: *mut aim_pvs_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get a string description of the given pvs.\n @param pvs The object to query.\n @returns A string describing the pvs. Do not modify or free."]
    pub fn aim_pvs_desc_get(pvs: *mut aim_pvs_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Log function for all pvs.\n @param cookie Pointer to relevant PVS.\n @param flag Associated log flag.\n @param str String to log."]
    pub fn aim_pvs_logf(
        cookie: *mut ::std::os::raw::c_void,
        flag: aim_log_flag_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Open a PVS FILE stream.\n @param path The filename to open.\n @param mode The open mode.\n\n @note the file will be closed when you call aim_pvs_destroy()"]
    pub fn aim_pvs_fopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut aim_pvs_t;
}
extern "C" {
    #[doc = " @brief Create a PVS which collects and buffers output.\n @note When finished, you should call aim_pvs_destroy()."]
    pub fn aim_pvs_buffer_create() -> *mut aim_pvs_t;
}
extern "C" {
    #[doc = " @brief the current size of the output.\n @param pvs The PVS"]
    pub fn aim_pvs_buffer_size(pvs: *mut aim_pvs_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the entire output buffer.\n @param pvs The pvs.\n @returns A new buffer containing the entire output.\n @note You must free the buffer when you're done."]
    pub fn aim_pvs_buffer_get(pvs: *mut aim_pvs_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Discard all output.\n @param pvs The pvs."]
    pub fn aim_pvs_buffer_reset(pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " @brief Iterate over all buffers.\n @param pvs The pvs.\n @param [out] size The size of the returned data.\n @returns The next buffer if available.\n @returns NULL if no more data is available.\n @note The returned pointer must not be freed."]
    pub fn aim_pvs_buffer_iterate(
        pvs: *mut aim_pvs_t,
        size: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief String duplication.\n @param s The string to duplicate.\n @returns The duplicated string.\n\n @note The strdup() function is not a C99 standard library function.\n We provide our own for portability."]
    pub fn aim_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Safe, reentrant strtok_r()\n @param str The string to tokenize.\n @param delim The delimiter list.\n @param saveptr Pointer for internal state.\n\n @note The strtok_r() function is not a standard library function.\n We provide our own for portability."]
    pub fn aim_strtok_r(
        str_: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        saveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Predictable, C99-compliant version of snprintf()\n @param str The buffer\n @param size The size\n @param fmt The format\n\n @note Implemented because we rely on the C99 behavior wrt character counts\n and not all platforms implement it."]
    pub fn aim_snprintf(
        str_: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Predicatable, C99-compliant version of vsnprintf()\n @param str The buffer\n @param size The size\n @param fmt The format\n @param vargs The arguments\n\n @note Implemented because we rely on the C99 behavior wrt character counts\n and not all platforms implement it."]
    pub fn aim_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Duplicate a string with formatting.\n @param fmt The format"]
    pub fn aim_fstrdup(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Duplicate a string with formatting.\n @param fmt The format.\n @param vargs The args."]
    pub fn aim_vfstrdup(
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Duplicate a string with AIM datatype formatting.\n @param fmt The format"]
    pub fn aim_dfstrdup(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Duplicate a string with AIM datatype formatting.\n @param fmt The format.\n @param vargs The args."]
    pub fn aim_vdfstrdup(
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Portable strlcpy\n @param dst Destination\n @param src Source\n @param size Size"]
    pub fn aim_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Format a byte buffer as a printable string.\n @param data Data buffer.\n @param size size of the data.\n @param columns Number of output columns.\n @note You must free the result when finished."]
    pub fn aim_bytes_to_string(
        data: *mut u8,
        size: ::std::os::raw::c_int,
        columns: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Interpret a string as a byte buffer.\n @param src Source string.\n @param [out] size Receives the size of the returned buffer.\n @note You must free the result when finished."]
    pub fn aim_bytes_from_string(
        src: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " @brief Join strings.\n @param string The join string.\n @param strings The strings to join.\n @param count The number of strings.\n @note You must free the returned buffer."]
    pub fn aim_strjoin(
        string: *const ::std::os::raw::c_char,
        strings: *mut *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Tokenizer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_tokens_s {
    #[doc = " total token count"]
    pub count: ::std::os::raw::c_int,
    #[doc = " tokens"]
    pub tokens: *mut *const ::std::os::raw::c_char,
    #[doc = " Internal"]
    pub _string: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_tokens_s"][::std::mem::size_of::<aim_tokens_s>() - 24usize];
    ["Alignment of aim_tokens_s"][::std::mem::align_of::<aim_tokens_s>() - 8usize];
    ["Offset of field: aim_tokens_s::count"][::std::mem::offset_of!(aim_tokens_s, count) - 0usize];
    ["Offset of field: aim_tokens_s::tokens"]
        [::std::mem::offset_of!(aim_tokens_s, tokens) - 8usize];
    ["Offset of field: aim_tokens_s::_string"]
        [::std::mem::offset_of!(aim_tokens_s, _string) - 16usize];
};
#[doc = " Tokenizer"]
pub type aim_tokens_t = aim_tokens_s;
extern "C" {
    #[doc = " @brief Split a string.\n @param string The input string.\n @param delim The token delimiters.\n @note Call aim_tokens_free() when done."]
    pub fn aim_strsplit(
        string: *const ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
    ) -> *mut aim_tokens_t;
}
extern "C" {
    #[doc = " @brief Free an AIM tokens structure.\n @param tokens The structure to free."]
    pub fn aim_tokens_free(tokens: *mut aim_tokens_t);
}
extern "C" {
    #[doc = " @brief Convert the source string to printable characters only.\n @param src The source string.\n @param replacement The replacement character for unprintable characters.\n @returns A copy of the source string with printable characters replaced by the given character.\n @note You must free the returned buffer."]
    pub fn aim_pstrdup(
        src: *const ::std::os::raw::c_char,
        replacement: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return current running-under-valgrind status.\n @returns 0 If not running under valgrind.\n @returns 1 If running under valgrind.\n @returns -1 If status is unknown (support not compiled in)."]
    pub fn aim_valgrind_status() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[doc = " Link structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_links {
    #[doc = " Previous"]
    pub prev: *mut list_links,
    #[doc = " Next"]
    pub next: *mut list_links,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of list_links"][::std::mem::size_of::<list_links>() - 16usize];
    ["Alignment of list_links"][::std::mem::align_of::<list_links>() - 8usize];
    ["Offset of field: list_links::prev"][::std::mem::offset_of!(list_links, prev) - 0usize];
    ["Offset of field: list_links::next"][::std::mem::offset_of!(list_links, next) - 8usize];
};
#[doc = " Link structure."]
pub type list_links_t = list_links;
#[doc = " List head."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    #[doc = " Links"]
    pub links: list_links,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of list_head"][::std::mem::size_of::<list_head>() - 16usize];
    ["Alignment of list_head"][::std::mem::align_of::<list_head>() - 8usize];
    ["Offset of field: list_head::links"][::std::mem::offset_of!(list_head, links) - 0usize];
};
#[doc = " List head."]
pub type list_head_t = list_head;
#[doc = " Context passed to all datatype handlers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_datatype_context_s {
    #[doc = " The registrant's datatype structure."]
    pub dt: *mut aim_datatype_s,
    #[doc = " PVS for error messages if appropate."]
    pub epvs: *mut aim_pvs_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_datatype_context_s"][::std::mem::size_of::<aim_datatype_context_s>() - 16usize];
    ["Alignment of aim_datatype_context_s"]
        [::std::mem::align_of::<aim_datatype_context_s>() - 8usize];
    ["Offset of field: aim_datatype_context_s::dt"]
        [::std::mem::offset_of!(aim_datatype_context_s, dt) - 0usize];
    ["Offset of field: aim_datatype_context_s::epvs"]
        [::std::mem::offset_of!(aim_datatype_context_s, epvs) - 8usize];
};
#[doc = " Context passed to all datatype handlers."]
pub type aim_datatype_context_t = aim_datatype_context_s;
#[doc = "//**\n\n The \"from_string\" prototype.\n"]
pub type aim_datatype_from_str_f = ::std::option::Option<
    unsafe extern "C" fn(
        dtc: *mut aim_datatype_context_t,
        arg: *const ::std::os::raw::c_char,
        vargs: *mut aim_va_list_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "//**\n\n The \"to_string\" prototype.\n"]
pub type aim_datatype_to_str_f = ::std::option::Option<
    unsafe extern "C" fn(
        dtc: *mut aim_datatype_context_t,
        vargs: *mut aim_va_list_t,
        rv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Register a custom datatype.\n @param c Optional single character that refers to this datatype.\n @param type The full name of this datatype.\n @param desc The description of this datatype.\n @param froms The handler that converts a string to this datatype.\n @param tos The handler that converts this datatype to a string.\n @param cookie Client cookie to be passed to the handlers when called."]
    pub fn aim_datatype_register(
        c: ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        froms: aim_datatype_from_str_f,
        tos: aim_datatype_to_str_f,
        cookie: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unregister the given datatype.\n @param c Optional single character that refers to this datatype.\n @param type The full name of the datatype to unregister."]
    pub fn aim_datatype_unregister(
        c: ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize the datatypes infrastructure."]
    pub fn aim_datatypes_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Deinitialize the datatypes infrastructure."]
    pub fn aim_datatypes_denit();
}
#[doc = " The builtin {map} datatype provides conversion between strings\n and integers.\n\n This structure defines the input data for the {map} datatype."]
pub type aim_datatype_map_t = aim_map_si_t;
extern "C" {
    #[doc = " @brief Register a mapping datatype.\n @param c The optional single character that refers to this datatype.\n @param type The full name for this datatype.\n @param desc The description of this datatype.\n @param map The map table defining the allowable values for this datatype."]
    pub fn aim_datatype_register_map(
        c: ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        map: *mut aim_datatype_map_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Register a flag mapping datatype.\n @param c The optional single character that refers to this datatype.\n @param type The full name for this datatype.\n @param desc The description of this datatype.\n @param map The map table defining the allowable values for this datatype.\n\n This assumes the input is a uint32_t representing flags defined\n in the map table."]
    pub fn aim_datatype_register_fmap(
        c: ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        map: *mut aim_datatype_map_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Datatype forward."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_datatype_s {
    #[doc = " Internal list management"]
    pub links: list_links_t,
    #[doc = " character shortcut"]
    pub c: ::std::os::raw::c_char,
    #[doc = " typename, used with \"{type}\""]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = " Human description of this type"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " from-string handler for this datatype."]
    pub from_str: aim_datatype_from_str_f,
    #[doc = " to-string handler for this datatype."]
    pub to_str: aim_datatype_to_str_f,
    #[doc = " private cookie"]
    pub cookie: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_datatype_s"][::std::mem::size_of::<aim_datatype_s>() - 64usize];
    ["Alignment of aim_datatype_s"][::std::mem::align_of::<aim_datatype_s>() - 8usize];
    ["Offset of field: aim_datatype_s::links"]
        [::std::mem::offset_of!(aim_datatype_s, links) - 0usize];
    ["Offset of field: aim_datatype_s::c"][::std::mem::offset_of!(aim_datatype_s, c) - 16usize];
    ["Offset of field: aim_datatype_s::type_"]
        [::std::mem::offset_of!(aim_datatype_s, type_) - 24usize];
    ["Offset of field: aim_datatype_s::desc"]
        [::std::mem::offset_of!(aim_datatype_s, desc) - 32usize];
    ["Offset of field: aim_datatype_s::from_str"]
        [::std::mem::offset_of!(aim_datatype_s, from_str) - 40usize];
    ["Offset of field: aim_datatype_s::to_str"]
        [::std::mem::offset_of!(aim_datatype_s, to_str) - 48usize];
    ["Offset of field: aim_datatype_s::cookie"]
        [::std::mem::offset_of!(aim_datatype_s, cookie) - 56usize];
};
#[doc = " Datatype forward."]
pub type aim_datatype_t = aim_datatype_s;
extern "C" {
    #[doc = " @brief Register a datatype using the native datatype structure.\n @param dt Pointer to the datatype structure."]
    pub fn aim_datatype_register_struct(dt: *mut aim_datatype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find the datatype management structure for the requested type.\n @param c Optional shortcut character for the datatype.\n @param type The full name of the datatype.\n\n @returns NULL if there is no datatype registered by that name.\n @returns The pointer to the datatype information structure if found.\n"]
    pub fn aim_datatype_find(
        c: ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut aim_datatype_t;
}
extern "C" {
    #[doc = " @brief printf-style output to any PVS with custom datatype formatting.\n @param pvs The PVS output stream.\n @param fmt The format string."]
    pub fn aim_printf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief vprintf-style output to any PVS with custom datatype formatting.\n @param pvs The PVS output stream.\n @param fmt The format string.\n @param vargs The format arguments.\n @note This does not include custom datatype processing.\n @note Most clients should call aim_vprintf() instead."]
    pub fn aim_vprintf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief vprintf-style output to any PVS with custom datatype formatting.\n @param pvs The PVS output stream.\n @param fmt The format string.\n @param vargs The AIM variable argument structure.\n @note This does not include custom datatype processing.\n @note Most clients should call aim_avprintf() instead."]
    pub fn aim_avprintf(
        pvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut aim_va_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Parse the given datatypes.\n @param args The arguments containing the string representations of the\n the given types.\n @param epvs Output PVS for parsing error messages, if relevent.\n @param fmt The datatype format specifiers."]
    pub fn aim_sparse(
        args: *mut *mut ::std::os::raw::c_char,
        epvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Parse the given datatypes (vararg version).\n @param args The arguments contaiining the string representations fo the\n given types.\n @param epvs Output PVS for parsing error messages, if relevent.\n @param fmt The datatype format specifiers.\n @param vargs The datatype arguments."]
    pub fn aim_vsparse(
        args: *mut *mut ::std::os::raw::c_char,
        epvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Parse the given datatypes (AIM vararg version).\n @param args The arguments contaiining the string representations fo the\n given types.\n @param epvs Output PVS for parsing error messages, if relevent.\n @param fmt The datatype format specifiers.\n @param vargs The datatype arguments."]
    pub fn aim_avsparse(
        args: *mut *mut ::std::os::raw::c_char,
        epvs: *mut aim_pvs_t,
        fmt: *const ::std::os::raw::c_char,
        vargs: *mut aim_va_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Parse the given string as the given datatype.\n @param arg Input string.\n @param epvs Output PVS for error messages, if relevent.\n @param c The datatype character shortcut, if relevent.\n @param type The datatype namne, if relevent.\n @param vargs The datatype argument(s)."]
    pub fn aim_avsparse_type(
        arg: *const ::std::os::raw::c_char,
        epvs: *mut aim_pvs_t,
        c: ::std::os::raw::c_char,
        type_: *mut ::std::os::raw::c_char,
        vargs: *mut aim_va_list_t,
    ) -> ::std::os::raw::c_int;
}
pub const aim_error_e_AIM_ERROR_NONE: aim_error_e = 0;
pub const aim_error_e_AIM_ERROR_PARAM: aim_error_e = -1;
pub const aim_error_e_AIM_ERROR_NOT_FOUND: aim_error_e = -2;
pub const aim_error_e_AIM_ERROR_INTERNAL: aim_error_e = -3;
#[doc = " aim_error"]
pub type aim_error_e = ::std::os::raw::c_int;
#[doc = " aim_error"]
pub use self::aim_error_e as aim_error_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn aim_error_name(e: aim_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn aim_error_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut aim_error_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn aim_error_desc(e: aim_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn aim_error_valid(e: aim_error_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " aim_error_map table."]
    pub static mut aim_error_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " aim_error_desc_map table."]
    pub static mut aim_error_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " @brief Report an unrecoverable error.\n @param fmt Message format.\n @note The behavior of this function is platform\n specific, but should always be considered a termination event.\n"]
    pub fn aim_die(
        function: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
#[doc = " atomic bitmap storage type."]
pub type aim_bitmap_word_t = u32;
#[doc = " All bitmaps must contain this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap_hdr_s {
    #[doc = " The number of words in this bitmap"]
    pub wordcount: ::std::os::raw::c_int,
    #[doc = " bitmap words"]
    pub words: *mut aim_bitmap_word_t,
    #[doc = " Maximum allowable bit"]
    pub maxbit: ::std::os::raw::c_int,
    #[doc = " Indicates AIM allocated this bitmap structure"]
    pub allocated: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap_hdr_s"][::std::mem::size_of::<aim_bitmap_hdr_s>() - 24usize];
    ["Alignment of aim_bitmap_hdr_s"][::std::mem::align_of::<aim_bitmap_hdr_s>() - 8usize];
    ["Offset of field: aim_bitmap_hdr_s::wordcount"]
        [::std::mem::offset_of!(aim_bitmap_hdr_s, wordcount) - 0usize];
    ["Offset of field: aim_bitmap_hdr_s::words"]
        [::std::mem::offset_of!(aim_bitmap_hdr_s, words) - 8usize];
    ["Offset of field: aim_bitmap_hdr_s::maxbit"]
        [::std::mem::offset_of!(aim_bitmap_hdr_s, maxbit) - 16usize];
    ["Offset of field: aim_bitmap_hdr_s::allocated"]
        [::std::mem::offset_of!(aim_bitmap_hdr_s, allocated) - 20usize];
};
#[doc = " All bitmaps must contain this structure"]
pub type aim_bitmap_hdr_t = aim_bitmap_hdr_s;
#[doc = " A dynamically allocated bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap_t {
    #[doc = " bitmap hdr"]
    pub hdr: aim_bitmap_hdr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap_t"][::std::mem::size_of::<aim_bitmap_t>() - 24usize];
    ["Alignment of aim_bitmap_t"][::std::mem::align_of::<aim_bitmap_t>() - 8usize];
    ["Offset of field: aim_bitmap_t::hdr"][::std::mem::offset_of!(aim_bitmap_t, hdr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap32_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap32_s"][::std::mem::size_of::<aim_bitmap32_s>() - 32usize];
    ["Alignment of aim_bitmap32_s"][::std::mem::align_of::<aim_bitmap32_s>() - 8usize];
    ["Offset of field: aim_bitmap32_s::hdr"][::std::mem::offset_of!(aim_bitmap32_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap32_s::words"]
        [::std::mem::offset_of!(aim_bitmap32_s, words) - 24usize];
};
pub type aim_bitmap32_t = aim_bitmap32_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap64_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap64_s"][::std::mem::size_of::<aim_bitmap64_s>() - 32usize];
    ["Alignment of aim_bitmap64_s"][::std::mem::align_of::<aim_bitmap64_s>() - 8usize];
    ["Offset of field: aim_bitmap64_s::hdr"][::std::mem::offset_of!(aim_bitmap64_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap64_s::words"]
        [::std::mem::offset_of!(aim_bitmap64_s, words) - 24usize];
};
pub type aim_bitmap64_t = aim_bitmap64_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap96_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap96_s"][::std::mem::size_of::<aim_bitmap96_s>() - 40usize];
    ["Alignment of aim_bitmap96_s"][::std::mem::align_of::<aim_bitmap96_s>() - 8usize];
    ["Offset of field: aim_bitmap96_s::hdr"][::std::mem::offset_of!(aim_bitmap96_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap96_s::words"]
        [::std::mem::offset_of!(aim_bitmap96_s, words) - 24usize];
};
pub type aim_bitmap96_t = aim_bitmap96_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap128_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap128_s"][::std::mem::size_of::<aim_bitmap128_s>() - 40usize];
    ["Alignment of aim_bitmap128_s"][::std::mem::align_of::<aim_bitmap128_s>() - 8usize];
    ["Offset of field: aim_bitmap128_s::hdr"]
        [::std::mem::offset_of!(aim_bitmap128_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap128_s::words"]
        [::std::mem::offset_of!(aim_bitmap128_s, words) - 24usize];
};
pub type aim_bitmap128_t = aim_bitmap128_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap256_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap256_s"][::std::mem::size_of::<aim_bitmap256_s>() - 56usize];
    ["Alignment of aim_bitmap256_s"][::std::mem::align_of::<aim_bitmap256_s>() - 8usize];
    ["Offset of field: aim_bitmap256_s::hdr"]
        [::std::mem::offset_of!(aim_bitmap256_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap256_s::words"]
        [::std::mem::offset_of!(aim_bitmap256_s, words) - 24usize];
};
pub type aim_bitmap256_t = aim_bitmap256_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap512_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap512_s"][::std::mem::size_of::<aim_bitmap512_s>() - 88usize];
    ["Alignment of aim_bitmap512_s"][::std::mem::align_of::<aim_bitmap512_s>() - 8usize];
    ["Offset of field: aim_bitmap512_s::hdr"]
        [::std::mem::offset_of!(aim_bitmap512_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap512_s::words"]
        [::std::mem::offset_of!(aim_bitmap512_s, words) - 24usize];
};
pub type aim_bitmap512_t = aim_bitmap512_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_bitmap4096_s {
    pub hdr: aim_bitmap_hdr_t,
    pub words: [aim_bitmap_word_t; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_bitmap4096_s"][::std::mem::size_of::<aim_bitmap4096_s>() - 536usize];
    ["Alignment of aim_bitmap4096_s"][::std::mem::align_of::<aim_bitmap4096_s>() - 8usize];
    ["Offset of field: aim_bitmap4096_s::hdr"]
        [::std::mem::offset_of!(aim_bitmap4096_s, hdr) - 0usize];
    ["Offset of field: aim_bitmap4096_s::words"]
        [::std::mem::offset_of!(aim_bitmap4096_s, words) - 24usize];
};
pub type aim_bitmap4096_t = aim_bitmap4096_s;
extern "C" {
    #[doc = " @brief Allocate a dynamic bitmap structure.\n @param [out] rv Receives the new bitmap structure.\n If rv is NULL, a new structure will be allocated.\n @param bitcount The number of bits required.\n @returns A pointer to the new bitmap structure."]
    pub fn aim_bitmap_alloc(
        rv: *mut aim_bitmap_t,
        bitcount: ::std::os::raw::c_int,
    ) -> *mut aim_bitmap_t;
}
extern "C" {
    #[doc = " @brief Free a bitmap structure.\n @param bmap The bitmap structure to free."]
    pub fn aim_bitmap_free(bmap: *mut aim_bitmap_t);
}
extern "C" {
    #[doc = " @brief Allocate memory.\n @param size Size.\n\n The returned memory is uninitialized.\n Aborts if allocation fails."]
    pub fn aim_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Zero'ed memory alloc.\n @param size Size.\n\n Aborts if allocation fails."]
    pub fn aim_zmalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Resize memory.\n @param ptr Allocated memory.\n @param size New size.\n\n Usual realloc semantics: if ptr is NULL then a new allocation is made, and\n is size is zero then the memory is freed. Otherwise the memory is resized\n and possibly moved.\n\n Aborts if allocation fails."]
    pub fn aim_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free memory allocated by aim_zmalloc()\n @param data The memory to free."]
    pub fn aim_free(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Duplicate memory.\n @param src Source memory.\n @param size Size.\n @returns a new copy of the data.\n\n Aborts if allocation fails."]
    pub fn aim_memdup(src: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Duplicate memory.\n @param src Source memory;\n @param src_size Size to copy.\n @param alloc_size Size to allocate.\n\n Aborts if allocation fails."]
    pub fn aim_memndup(
        src: *mut ::std::os::raw::c_void,
        src_size: usize,
        alloc_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_TO_DBGLOG: aim_log_handler_option_e = 0;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_TO_SYSLOG: aim_log_handler_option_e = 1;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_TO_STDOUT: aim_log_handler_option_e = 2;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_TO_STDERR: aim_log_handler_option_e = 3;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_LAST: aim_log_handler_option_e = 3;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_COUNT: aim_log_handler_option_e = 4;
pub const aim_log_handler_option_e_AIM_LOG_HANDLER_OPTION_INVALID: aim_log_handler_option_e = -1;
#[doc = " aim_log_handler_option"]
pub type aim_log_handler_option_e = ::std::os::raw::c_int;
#[doc = " aim_log_handler_option"]
pub use self::aim_log_handler_option_e as aim_log_handler_option_t;
pub const aim_log_handler_flag_e_AIM_LOG_HANDLER_FLAG_TO_DBGLOG: aim_log_handler_flag_e = 1;
pub const aim_log_handler_flag_e_AIM_LOG_HANDLER_FLAG_TO_SYSLOG: aim_log_handler_flag_e = 2;
pub const aim_log_handler_flag_e_AIM_LOG_HANDLER_FLAG_TO_STDOUT: aim_log_handler_flag_e = 4;
pub const aim_log_handler_flag_e_AIM_LOG_HANDLER_FLAG_TO_STDERR: aim_log_handler_flag_e = 8;
#[doc = " aim_log_handler_flag"]
pub type aim_log_handler_flag_e = ::std::os::raw::c_uint;
#[doc = " aim_log_handler_flag"]
pub use self::aim_log_handler_flag_e as aim_log_handler_flag_t;
#[doc = " Configuration block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_log_handler_config_s {
    #[doc = " Flags: see AIM_LOG_HANDLER_FLAG_* above"]
    pub flags: u32,
    #[doc = " Name of debug log file, optionally with full or relative path"]
    pub debug_log_name: *mut ::std::os::raw::c_char,
    #[doc = " Name of rotate log file, optionally with full or relative path"]
    pub rotate_log_name: *mut ::std::os::raw::c_char,
    #[doc = " Maximum number of bytes beyond which the debug log will be rotated"]
    pub max_debug_log_size: u32,
    #[doc = " Maximum number of rotated debug logs, excluding the actual debug log"]
    pub max_debug_logs: u32,
    #[doc = " Syslog facility to use (if applicable)"]
    pub syslog_facility: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aim_log_handler_config_s"]
        [::std::mem::size_of::<aim_log_handler_config_s>() - 40usize];
    ["Alignment of aim_log_handler_config_s"]
        [::std::mem::align_of::<aim_log_handler_config_s>() - 8usize];
    ["Offset of field: aim_log_handler_config_s::flags"]
        [::std::mem::offset_of!(aim_log_handler_config_s, flags) - 0usize];
    ["Offset of field: aim_log_handler_config_s::debug_log_name"]
        [::std::mem::offset_of!(aim_log_handler_config_s, debug_log_name) - 8usize];
    ["Offset of field: aim_log_handler_config_s::rotate_log_name"]
        [::std::mem::offset_of!(aim_log_handler_config_s, rotate_log_name) - 16usize];
    ["Offset of field: aim_log_handler_config_s::max_debug_log_size"]
        [::std::mem::offset_of!(aim_log_handler_config_s, max_debug_log_size) - 24usize];
    ["Offset of field: aim_log_handler_config_s::max_debug_logs"]
        [::std::mem::offset_of!(aim_log_handler_config_s, max_debug_logs) - 28usize];
    ["Offset of field: aim_log_handler_config_s::syslog_facility"]
        [::std::mem::offset_of!(aim_log_handler_config_s, syslog_facility) - 32usize];
};
#[doc = " Configuration block."]
pub type aim_log_handler_config_t = aim_log_handler_config_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aim_log_handler_s {
    _unused: [u8; 0],
}
pub type aim_log_handler_t = *mut aim_log_handler_s;
extern "C" {
    #[doc = " @brief Initialize the AIM log handler system."]
    pub fn aim_log_handler_init();
}
extern "C" {
    #[doc = " @brief Deinitialize the AIM log handler system."]
    pub fn aim_log_handler_denit();
}
extern "C" {
    pub fn aim_log_handler_basic_config_get(debug_logs: *mut u32, debug_file_size: *mut u32);
}
extern "C" {
    pub fn aim_log_handler_basic_config_set(debug_logs: u32, debug_file_size: u32);
}
extern "C" {
    #[doc = " Create an AIM log handler instance.\n @param config The handler configurtion.\n @returns Object pointer."]
    pub fn aim_log_handler_create(config: *mut aim_log_handler_config_t) -> aim_log_handler_t;
}
extern "C" {
    #[doc = " Destroy an AIM log handler instance."]
    pub fn aim_log_handler_destroy(handler: aim_log_handler_t);
}
extern "C" {
    #[doc = " @brief AIM log handler callback.\n @param Cookie log handler cookie. Must be an aim_log_handler_t.\n @param flag The AIM log flag.\n @param str The log message."]
    pub fn aim_log_handler_logf(
        cookie: *mut ::std::os::raw::c_void,
        flag: aim_log_flag_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Basic initialization for console and daemonized clients.\n @param ident The syslog ident to use (optional)\n @param debug_log_file  The name of the debug log file (optional)\n @param rotate_log_file  The name of the rotate log file (optional)\n @param max_debug_size   Maximum debug log size.\n @param max_debug_count  Maximum number of rotated debug logs.\n\n @note This is designed to be a simple and generic initialization\n for both daemonized and console-based clients."]
    pub fn aim_log_handler_basic_init_all(
        ident: *const ::std::os::raw::c_char,
        debug_log_file: *const ::std::os::raw::c_char,
        rotate_log_file: *const ::std::os::raw::c_char,
        max_debug_log_size: ::std::os::raw::c_int,
        max_debug_logs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Deinitialize basic log handling support."]
    pub fn aim_log_handler_basic_denit_all();
}
extern "C" {
    #[doc = " Enum names."]
    pub fn aim_log_handler_flag_name(e: aim_log_handler_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn aim_log_handler_flag_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut aim_log_handler_flag_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn aim_log_handler_flag_desc(e: aim_log_handler_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn aim_log_handler_flag_valid(e: aim_log_handler_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " aim_log_handler_flag_map table."]
    pub static mut aim_log_handler_flag_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " aim_log_handler_flag_desc_map table."]
    pub static mut aim_log_handler_flag_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn aim_log_handler_option_name(
        e: aim_log_handler_option_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn aim_log_handler_option_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut aim_log_handler_option_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn aim_log_handler_option_desc(
        e: aim_log_handler_option_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " aim_log_handler_option_map table."]
    pub static mut aim_log_handler_option_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " aim_log_handler_option_desc_map table."]
    pub static mut aim_log_handler_option_desc_map: [aim_map_si_t; 0usize];
}
#[doc = " Configuration settings structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_config_settings_s {
    #[doc = " name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " value"]
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_config_settings_s"][::std::mem::size_of::<onlp_config_settings_s>() - 16usize];
    ["Alignment of onlp_config_settings_s"]
        [::std::mem::align_of::<onlp_config_settings_s>() - 8usize];
    ["Offset of field: onlp_config_settings_s::name"]
        [::std::mem::offset_of!(onlp_config_settings_s, name) - 0usize];
    ["Offset of field: onlp_config_settings_s::value"]
        [::std::mem::offset_of!(onlp_config_settings_s, value) - 8usize];
};
#[doc = " Configuration settings structure."]
pub type onlp_config_settings_t = onlp_config_settings_s;
extern "C" {
    #[doc = " Configuration settings table. */\n/** onlp_config_settings table."]
    pub static mut onlp_config_settings: [onlp_config_settings_t; 0usize];
}
extern "C" {
    #[doc = " @brief Lookup a configuration setting.\n @param setting The name of the configuration option to lookup."]
    pub fn onlp_config_lookup(
        setting: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Show the compile-time configuration.\n @param pvs The output stream."]
    pub fn onlp_config_show(pvs: *mut aim_pvs_s) -> ::std::os::raw::c_int;
}
pub const onlp_status_e_ONLP_STATUS_OK: onlp_status_e = 0;
pub const onlp_status_e_ONLP_STATUS_E_GENERIC: onlp_status_e = -1;
pub const onlp_status_e_ONLP_STATUS_E_UNSUPPORTED: onlp_status_e = -10;
pub const onlp_status_e_ONLP_STATUS_E_MISSING: onlp_status_e = -11;
pub const onlp_status_e_ONLP_STATUS_E_INVALID: onlp_status_e = -12;
pub const onlp_status_e_ONLP_STATUS_E_INTERNAL: onlp_status_e = -13;
pub const onlp_status_e_ONLP_STATUS_E_PARAM: onlp_status_e = -14;
pub const onlp_status_e_ONLP_STATUS_E_I2C: onlp_status_e = -15;
#[doc = " onlp_status"]
pub type onlp_status_e = ::std::os::raw::c_int;
#[doc = " onlp_status"]
pub use self::onlp_status_e as onlp_status_t;
extern "C" {
    #[doc = " @brief Initialize all subsystems."]
    pub fn onlp_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onlp_denit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Dump the current platform data.\n @param pvs The output pvs"]
    pub fn onlp_platform_dump(pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    pub fn onlp_platform_show(pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_status_name(e: onlp_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_status_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_status_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_status_desc(e: onlp_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_status_valid(e: onlp_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_status_map table."]
    pub static mut onlp_status_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_status_desc_map table."]
    pub static mut onlp_status_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    pub fn IOF_ResetDevice(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_OutByte(Address: ::std::os::raw::c_uint, Data: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn IOF_OutWord(Address: ::std::os::raw::c_uint, Data: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn IOF_OutDword(Address: ::std::os::raw::c_uint, Data: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn IOF_InpByte(Address: ::std::os::raw::c_uint) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn IOF_InpWord(Address: ::std::os::raw::c_uint) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_InpDword(Address: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetEcu(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_GetFlags(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetMemFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetMemFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetCntFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetCntFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDoFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetDoFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDiFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetDiFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetAoFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetAoFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetAiFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetAiFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetSigFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetSigFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetBmFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetBmFlag(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flag: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_SetEcuCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetEcuCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetEcuCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetEcuCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_ResetFlags(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Flags: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_ResetMem(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_GetMemStatus(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetMemCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetMemCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetMemCommandD2(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data1: ::std::os::raw::c_ulong,
        Data2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetMemCommandD2(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data1: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetMemCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetMemCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_ResetAi(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_GetAiData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetAiStatus(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_OpenAiGate(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_CloseAiGate(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_SetAiCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetAiCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetAiCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetAiCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_SetAiEEPROM(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetAiEEPROM(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_ResetAo(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_SetAoData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Data: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetAoData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetAoStatus(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_OpenAoGate(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_CloseAoGate(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_SetAoCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetAoCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetAoCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetAoCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_SetAoEEPROM(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetAoEEPROM(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_GetCntStatus(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Channel: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetCntCommandD1(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetCntCommandD1(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetCntCommandD2(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data1: ::std::os::raw::c_ulong,
        Data2: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetCntCommandD2(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data1: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_ResetDi(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_GetDiData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetDiMask(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_SetDiCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDiCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetDiCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetDiCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn IOF_ResetDo(BoardNo: ::std::os::raw::c_ushort, Address: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn IOF_SetDoData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        DoData: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDoData(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetDoMask(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Mask: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDoMask(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetDoCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        Data: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn IOF_GetDoCommandD(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn IOF_SetDoCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
        DataHigh: ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn IOF_GetDoCommandW(
        BoardNo: ::std::os::raw::c_ushort,
        Address: ::std::os::raw::c_uint,
        Command: ::std::os::raw::c_ulong,
        DataLow: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_ushort;
}
#[doc = " The ONIE specification defines the format of the system\n eeprom and the available fields that may be described there.\n\n This structure contains the decoded fields for application\n and platform use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_onie_info_s {
    pub product_name: *mut ::std::os::raw::c_char,
    pub part_number: *mut ::std::os::raw::c_char,
    pub serial_number: *mut ::std::os::raw::c_char,
    pub mac: [u8; 6usize],
    pub manufacture_date: *mut ::std::os::raw::c_char,
    pub device_version: u8,
    pub label_revision: *mut ::std::os::raw::c_char,
    pub platform_name: *mut ::std::os::raw::c_char,
    pub onie_version: *mut ::std::os::raw::c_char,
    pub mac_range: u16,
    pub manufacturer: *mut ::std::os::raw::c_char,
    pub country_code: *mut ::std::os::raw::c_char,
    pub vendor: *mut ::std::os::raw::c_char,
    pub diag_version: *mut ::std::os::raw::c_char,
    pub service_tag: *mut ::std::os::raw::c_char,
    pub crc: u32,
    #[doc = " Vendor Extensions list, if available."]
    pub vx_list: list_head_t,
    pub _hdr_id_string: *mut ::std::os::raw::c_char,
    pub _hdr_version: u8,
    pub _hdr_length: u8,
    pub _hdr_valid_crc: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_onie_info_s"][::std::mem::size_of::<onlp_onie_info_s>() - 160usize];
    ["Alignment of onlp_onie_info_s"][::std::mem::align_of::<onlp_onie_info_s>() - 8usize];
    ["Offset of field: onlp_onie_info_s::product_name"]
        [::std::mem::offset_of!(onlp_onie_info_s, product_name) - 0usize];
    ["Offset of field: onlp_onie_info_s::part_number"]
        [::std::mem::offset_of!(onlp_onie_info_s, part_number) - 8usize];
    ["Offset of field: onlp_onie_info_s::serial_number"]
        [::std::mem::offset_of!(onlp_onie_info_s, serial_number) - 16usize];
    ["Offset of field: onlp_onie_info_s::mac"]
        [::std::mem::offset_of!(onlp_onie_info_s, mac) - 24usize];
    ["Offset of field: onlp_onie_info_s::manufacture_date"]
        [::std::mem::offset_of!(onlp_onie_info_s, manufacture_date) - 32usize];
    ["Offset of field: onlp_onie_info_s::device_version"]
        [::std::mem::offset_of!(onlp_onie_info_s, device_version) - 40usize];
    ["Offset of field: onlp_onie_info_s::label_revision"]
        [::std::mem::offset_of!(onlp_onie_info_s, label_revision) - 48usize];
    ["Offset of field: onlp_onie_info_s::platform_name"]
        [::std::mem::offset_of!(onlp_onie_info_s, platform_name) - 56usize];
    ["Offset of field: onlp_onie_info_s::onie_version"]
        [::std::mem::offset_of!(onlp_onie_info_s, onie_version) - 64usize];
    ["Offset of field: onlp_onie_info_s::mac_range"]
        [::std::mem::offset_of!(onlp_onie_info_s, mac_range) - 72usize];
    ["Offset of field: onlp_onie_info_s::manufacturer"]
        [::std::mem::offset_of!(onlp_onie_info_s, manufacturer) - 80usize];
    ["Offset of field: onlp_onie_info_s::country_code"]
        [::std::mem::offset_of!(onlp_onie_info_s, country_code) - 88usize];
    ["Offset of field: onlp_onie_info_s::vendor"]
        [::std::mem::offset_of!(onlp_onie_info_s, vendor) - 96usize];
    ["Offset of field: onlp_onie_info_s::diag_version"]
        [::std::mem::offset_of!(onlp_onie_info_s, diag_version) - 104usize];
    ["Offset of field: onlp_onie_info_s::service_tag"]
        [::std::mem::offset_of!(onlp_onie_info_s, service_tag) - 112usize];
    ["Offset of field: onlp_onie_info_s::crc"]
        [::std::mem::offset_of!(onlp_onie_info_s, crc) - 120usize];
    ["Offset of field: onlp_onie_info_s::vx_list"]
        [::std::mem::offset_of!(onlp_onie_info_s, vx_list) - 128usize];
    ["Offset of field: onlp_onie_info_s::_hdr_id_string"]
        [::std::mem::offset_of!(onlp_onie_info_s, _hdr_id_string) - 144usize];
    ["Offset of field: onlp_onie_info_s::_hdr_version"]
        [::std::mem::offset_of!(onlp_onie_info_s, _hdr_version) - 152usize];
    ["Offset of field: onlp_onie_info_s::_hdr_length"]
        [::std::mem::offset_of!(onlp_onie_info_s, _hdr_length) - 153usize];
    ["Offset of field: onlp_onie_info_s::_hdr_valid_crc"]
        [::std::mem::offset_of!(onlp_onie_info_s, _hdr_valid_crc) - 154usize];
};
#[doc = " The ONIE specification defines the format of the system\n eeprom and the available fields that may be described there.\n\n This structure contains the decoded fields for application\n and platform use."]
pub type onlp_onie_info_t = onlp_onie_info_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_onie_vx_s {
    pub links: list_links_t,
    pub data: [u8; 256usize],
    pub size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_onie_vx_s"][::std::mem::size_of::<onlp_onie_vx_s>() - 280usize];
    ["Alignment of onlp_onie_vx_s"][::std::mem::align_of::<onlp_onie_vx_s>() - 8usize];
    ["Offset of field: onlp_onie_vx_s::links"]
        [::std::mem::offset_of!(onlp_onie_vx_s, links) - 0usize];
    ["Offset of field: onlp_onie_vx_s::data"]
        [::std::mem::offset_of!(onlp_onie_vx_s, data) - 16usize];
    ["Offset of field: onlp_onie_vx_s::size"]
        [::std::mem::offset_of!(onlp_onie_vx_s, size) - 272usize];
};
pub type onlp_onie_vx_t = onlp_onie_vx_s;
extern "C" {
    #[doc = " Support for parsing ONIE eeprom data into the\n ONIE information structure is provided for all platforms."]
    pub fn onlp_onie_decode(
        rv: *mut onlp_onie_info_t,
        data: *const u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onlp_onie_decode_file(
        rv: *mut onlp_onie_info_t,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free an ONIE info structure."]
    pub fn onlp_onie_info_free(info: *mut onlp_onie_info_t);
}
extern "C" {
    #[doc = " Show the contents of an ONIE info structure."]
    pub fn onlp_onie_show(info: *mut onlp_onie_info_t, pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " Dump the contents of an ONIE info structure as JSON"]
    pub fn onlp_onie_show_json(info: *mut onlp_onie_info_t, pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " Read ONIE fields from a JSON file."]
    pub fn onlp_onie_read_json(
        info: *mut onlp_onie_info_t,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration settings structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlplib_config_settings_s {
    #[doc = " name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " value"]
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlplib_config_settings_s"]
        [::std::mem::size_of::<onlplib_config_settings_s>() - 16usize];
    ["Alignment of onlplib_config_settings_s"]
        [::std::mem::align_of::<onlplib_config_settings_s>() - 8usize];
    ["Offset of field: onlplib_config_settings_s::name"]
        [::std::mem::offset_of!(onlplib_config_settings_s, name) - 0usize];
    ["Offset of field: onlplib_config_settings_s::value"]
        [::std::mem::offset_of!(onlplib_config_settings_s, value) - 8usize];
};
#[doc = " Configuration settings structure."]
pub type onlplib_config_settings_t = onlplib_config_settings_s;
extern "C" {
    #[doc = " Configuration settings table. */\n/** onlplib_config_settings table."]
    pub static mut onlplib_config_settings: [onlplib_config_settings_t; 0usize];
}
extern "C" {
    #[doc = " @brief Lookup a configuration setting.\n @param setting The name of the configuration option to lookup."]
    pub fn onlplib_config_lookup(
        setting: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Show the compile-time configuration.\n @param pvs The output stream."]
    pub fn onlplib_config_show(pvs: *mut aim_pvs_s) -> ::std::os::raw::c_int;
}
#[doc = " Platform Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_platform_info_s {
    #[doc = " CPLD Versions\n\n Describes the internal CPLD version numbers, if applicable.\n"]
    pub cpld_versions: *mut ::std::os::raw::c_char,
    #[doc = " Additional version or platform information."]
    pub other_versions: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_platform_info_s"][::std::mem::size_of::<onlp_platform_info_s>() - 16usize];
    ["Alignment of onlp_platform_info_s"][::std::mem::align_of::<onlp_platform_info_s>() - 8usize];
    ["Offset of field: onlp_platform_info_s::cpld_versions"]
        [::std::mem::offset_of!(onlp_platform_info_s, cpld_versions) - 0usize];
    ["Offset of field: onlp_platform_info_s::other_versions"]
        [::std::mem::offset_of!(onlp_platform_info_s, other_versions) - 8usize];
};
#[doc = " Platform Information"]
pub type onlp_platform_info_t = onlp_platform_info_s;
extern "C" {
    pub fn onlp_platform_info_show_json(pi: *mut onlp_platform_info_t, pvs: *mut aim_pvs_t);
}
extern "C" {
    pub fn onlp_platform_info_show(pi: *mut onlp_platform_info_t, pvs: *mut aim_pvs_t);
}
#[doc = " System peripherals are identified by a 32bit OID.\n\n The First byte is the object-class identifier:\n    Thermal sensor object\n    Fan object\n    PSU object\n    LED object\n    MODULE object\n    etc..\n The remaining bytes are the object id."]
pub type onlp_oid_t = u32;
pub const onlp_oid_dump_e_ONLP_OID_DUMP_RECURSE: onlp_oid_dump_e = 1;
pub const onlp_oid_dump_e_ONLP_OID_DUMP_EVEN_IF_ABSENT: onlp_oid_dump_e = 2;
#[doc = " onlp_oid_dump"]
pub type onlp_oid_dump_e = ::std::os::raw::c_uint;
#[doc = " onlp_oid_dump"]
pub use self::onlp_oid_dump_e as onlp_oid_dump_t;
pub const onlp_oid_show_e_ONLP_OID_SHOW_RECURSE: onlp_oid_show_e = 1;
pub const onlp_oid_show_e_ONLP_OID_SHOW_EXTENDED: onlp_oid_show_e = 2;
pub const onlp_oid_show_e_ONLP_OID_SHOW_YAML: onlp_oid_show_e = 4;
#[doc = " onlp_oid_show"]
pub type onlp_oid_show_e = ::std::os::raw::c_uint;
#[doc = " onlp_oid_show"]
pub use self::onlp_oid_show_e as onlp_oid_show_t;
pub const onlp_oid_type_e_ONLP_OID_TYPE_SYS: onlp_oid_type_e = 1;
pub const onlp_oid_type_e_ONLP_OID_TYPE_THERMAL: onlp_oid_type_e = 2;
pub const onlp_oid_type_e_ONLP_OID_TYPE_FAN: onlp_oid_type_e = 3;
pub const onlp_oid_type_e_ONLP_OID_TYPE_PSU: onlp_oid_type_e = 4;
pub const onlp_oid_type_e_ONLP_OID_TYPE_LED: onlp_oid_type_e = 5;
pub const onlp_oid_type_e_ONLP_OID_TYPE_MODULE: onlp_oid_type_e = 6;
pub const onlp_oid_type_e_ONLP_OID_TYPE_RTC: onlp_oid_type_e = 7;
#[doc = " onlp_oid_type"]
pub type onlp_oid_type_e = ::std::os::raw::c_uint;
#[doc = " onlp_oid_type"]
pub use self::onlp_oid_type_e as onlp_oid_type_t;
pub type onlp_oid_desc_t = [::std::os::raw::c_char; 128usize];
pub type onlp_oid_table_t = [onlp_oid_t; 128usize];
#[doc = " All OID objects contain this header as the first member."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_oid_hdr_s {
    #[doc = " The OID"]
    pub id: onlp_oid_t,
    #[doc = " The description of this object."]
    pub description: onlp_oid_desc_t,
    #[doc = " The parent OID of this object."]
    pub poid: onlp_oid_t,
    #[doc = " The children of this OID"]
    pub coids: onlp_oid_table_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_oid_hdr_s"][::std::mem::size_of::<onlp_oid_hdr_s>() - 648usize];
    ["Alignment of onlp_oid_hdr_s"][::std::mem::align_of::<onlp_oid_hdr_s>() - 4usize];
    ["Offset of field: onlp_oid_hdr_s::id"][::std::mem::offset_of!(onlp_oid_hdr_s, id) - 0usize];
    ["Offset of field: onlp_oid_hdr_s::description"]
        [::std::mem::offset_of!(onlp_oid_hdr_s, description) - 4usize];
    ["Offset of field: onlp_oid_hdr_s::poid"]
        [::std::mem::offset_of!(onlp_oid_hdr_s, poid) - 132usize];
    ["Offset of field: onlp_oid_hdr_s::coids"]
        [::std::mem::offset_of!(onlp_oid_hdr_s, coids) - 136usize];
};
#[doc = " All OID objects contain this header as the first member."]
pub type onlp_oid_hdr_t = onlp_oid_hdr_s;
extern "C" {
    pub fn onlp_oid_dump(oid: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    pub fn onlp_oid_table_dump(table: *mut onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    pub fn onlp_oid_show(oid: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    pub fn onlp_oid_table_show(table: *mut onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
#[doc = " Iterator"]
pub type onlp_oid_iterate_f = ::std::option::Option<
    unsafe extern "C" fn(
        oid: onlp_oid_t,
        cookie: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Iterate over all platform OIDs.\n @param oid The root OID.\n @param type The OID type filter (optional)\n @param itf The iterator function.\n @param cookie The cookie."]
    pub fn onlp_oid_iterate(
        oid: onlp_oid_t,
        type_: onlp_oid_type_t,
        itf: onlp_oid_iterate_f,
        cookie: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the OID header for a given OID.\n @param oid The oid\n @param hdr [out] Receives the header"]
    pub fn onlp_oid_hdr_get(oid: onlp_oid_t, hdr: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_oid_dump_name(e: onlp_oid_dump_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_oid_dump_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_oid_dump_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_oid_dump_desc(e: onlp_oid_dump_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_oid_dump_valid(e: onlp_oid_dump_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_oid_dump_map table."]
    pub static mut onlp_oid_dump_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_oid_dump_desc_map table."]
    pub static mut onlp_oid_dump_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_oid_show_name(e: onlp_oid_show_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_oid_show_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_oid_show_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_oid_show_desc(e: onlp_oid_show_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_oid_show_valid(e: onlp_oid_show_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_oid_show_map table."]
    pub static mut onlp_oid_show_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_oid_show_desc_map table."]
    pub static mut onlp_oid_show_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_oid_type_name(e: onlp_oid_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_oid_type_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_oid_type_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_oid_type_desc(e: onlp_oid_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_oid_type_valid(e: onlp_oid_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_oid_type_map table."]
    pub static mut onlp_oid_type_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_oid_type_desc_map table."]
    pub static mut onlp_oid_type_desc_map: [aim_map_si_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_sys_info_s {
    #[doc = " OID Header"]
    pub hdr: onlp_oid_hdr_t,
    pub onie_info: onlp_onie_info_t,
    pub platform_info: onlp_platform_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_sys_info_s"][::std::mem::size_of::<onlp_sys_info_s>() - 824usize];
    ["Alignment of onlp_sys_info_s"][::std::mem::align_of::<onlp_sys_info_s>() - 8usize];
    ["Offset of field: onlp_sys_info_s::hdr"]
        [::std::mem::offset_of!(onlp_sys_info_s, hdr) - 0usize];
    ["Offset of field: onlp_sys_info_s::onie_info"]
        [::std::mem::offset_of!(onlp_sys_info_s, onie_info) - 648usize];
    ["Offset of field: onlp_sys_info_s::platform_info"]
        [::std::mem::offset_of!(onlp_sys_info_s, platform_info) - 808usize];
};
pub type onlp_sys_info_t = onlp_sys_info_s;
extern "C" {
    #[doc = " @brief Initialize the System API"]
    pub fn onlp_sys_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the system information structure.\n @param rv [out] Receives the system information."]
    pub fn onlp_sys_info_get(rv: *mut onlp_sys_info_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Free a system information structure."]
    pub fn onlp_sys_info_free(info: *mut onlp_sys_info_t);
}
extern "C" {
    #[doc = " @brief Get the system header."]
    pub fn onlp_sys_hdr_get(hdr: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief SYS OID debug dump.\n @param id The SYS OID.\n @param pvs The output pvs.\n @param flags The output flags.\n @note This output is designed for debugging."]
    pub fn onlp_sys_dump(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief Show the status of the given OID.\n @param id the SYS OID.\n @param pvs The output pvs.\n @param flags The output flags"]
    pub fn onlp_sys_show(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief SYS Ioctl\n @param code The ioctl code.\n @param ... Arguments"]
    pub fn onlp_sys_ioctl(code: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief SYS Ioctl\n @param code The ioctl code.\n @param vargs arguments."]
    pub fn onlp_sys_vioctl(
        code: ::std::os::raw::c_int,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Start the platform management thread."]
    pub fn onlp_sys_platform_manage_start(block: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Stop the platform management thread."]
    pub fn onlp_sys_platform_manage_stop(block: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Join the platform management thread."]
    pub fn onlp_sys_platform_manage_join() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Perform any pending platform management activities.\n @note  A call to this function will perform any pending\n platform management activities. It is not intended to block\n for an extended period of time."]
    pub fn onlp_sys_platform_manage_now();
}
extern "C" {
    pub fn onlp_sys_debug(
        pvs: *mut aim_pvs_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration settings structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sff_config_settings_s {
    #[doc = " name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " value"]
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sff_config_settings_s"][::std::mem::size_of::<sff_config_settings_s>() - 16usize];
    ["Alignment of sff_config_settings_s"]
        [::std::mem::align_of::<sff_config_settings_s>() - 8usize];
    ["Offset of field: sff_config_settings_s::name"]
        [::std::mem::offset_of!(sff_config_settings_s, name) - 0usize];
    ["Offset of field: sff_config_settings_s::value"]
        [::std::mem::offset_of!(sff_config_settings_s, value) - 8usize];
};
#[doc = " Configuration settings structure."]
pub type sff_config_settings_t = sff_config_settings_s;
extern "C" {
    #[doc = " Configuration settings table. */\n/** sff_config_settings table."]
    pub static mut sff_config_settings: [sff_config_settings_t; 0usize];
}
extern "C" {
    #[doc = " @brief Lookup a configuration setting.\n @param setting The name of the configuration option to lookup."]
    pub fn sff_config_lookup(
        setting: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Show the compile-time configuration.\n @param pvs The output stream."]
    pub fn sff_config_show(pvs: *mut aim_pvs_s) -> ::std::os::raw::c_int;
}
pub const sff_media_type_e_SFF_MEDIA_TYPE_COPPER: sff_media_type_e = 0;
pub const sff_media_type_e_SFF_MEDIA_TYPE_FIBER: sff_media_type_e = 1;
pub const sff_media_type_e_SFF_MEDIA_TYPE_LAST: sff_media_type_e = 1;
pub const sff_media_type_e_SFF_MEDIA_TYPE_COUNT: sff_media_type_e = 2;
pub const sff_media_type_e_SFF_MEDIA_TYPE_INVALID: sff_media_type_e = -1;
#[doc = " sff_media_type"]
pub type sff_media_type_e = ::std::os::raw::c_int;
#[doc = " sff_media_type"]
pub use self::sff_media_type_e as sff_media_type_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn sff_media_type_name(e: sff_media_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn sff_media_type_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut sff_media_type_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn sff_media_type_desc(e: sff_media_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sff_media_type_map table."]
    pub static mut sff_media_type_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " sff_media_type_desc_map table."]
    pub static mut sff_media_type_desc_map: [aim_map_si_t; 0usize];
}
pub const sff_module_caps_e_SFF_MODULE_CAPS_F_100: sff_module_caps_e = 1;
pub const sff_module_caps_e_SFF_MODULE_CAPS_F_1G: sff_module_caps_e = 2;
pub const sff_module_caps_e_SFF_MODULE_CAPS_F_10G: sff_module_caps_e = 4;
pub const sff_module_caps_e_SFF_MODULE_CAPS_F_40G: sff_module_caps_e = 8;
pub const sff_module_caps_e_SFF_MODULE_CAPS_F_100G: sff_module_caps_e = 16;
#[doc = " sff_module_caps"]
pub type sff_module_caps_e = ::std::os::raw::c_uint;
#[doc = " sff_module_caps"]
pub use self::sff_module_caps_e as sff_module_caps_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn sff_module_caps_name(e: sff_module_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn sff_module_caps_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut sff_module_caps_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn sff_module_caps_desc(e: sff_module_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn sff_module_caps_valid(e: sff_module_caps_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sff_module_caps_map table."]
    pub static mut sff_module_caps_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " sff_module_caps_desc_map table."]
    pub static mut sff_module_caps_desc_map: [aim_map_si_t; 0usize];
}
pub const sff_module_type_e_SFF_MODULE_TYPE_100G_AOC: sff_module_type_e = 0;
pub const sff_module_type_e_SFF_MODULE_TYPE_100G_BASE_CR4: sff_module_type_e = 1;
pub const sff_module_type_e_SFF_MODULE_TYPE_100G_BASE_SR4: sff_module_type_e = 2;
pub const sff_module_type_e_SFF_MODULE_TYPE_100G_BASE_LR4: sff_module_type_e = 3;
pub const sff_module_type_e_SFF_MODULE_TYPE_100G_CWDM4: sff_module_type_e = 4;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_CR4: sff_module_type_e = 5;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_SR4: sff_module_type_e = 6;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_LR4: sff_module_type_e = 7;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_LM4: sff_module_type_e = 8;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_ACTIVE: sff_module_type_e = 9;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_CR: sff_module_type_e = 10;
pub const sff_module_type_e_SFF_MODULE_TYPE_40G_BASE_SR2: sff_module_type_e = 11;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_SR: sff_module_type_e = 12;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_LR: sff_module_type_e = 13;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_LRM: sff_module_type_e = 14;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_ER: sff_module_type_e = 15;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_CR: sff_module_type_e = 16;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_SX: sff_module_type_e = 17;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_LX: sff_module_type_e = 18;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_ZR: sff_module_type_e = 19;
pub const sff_module_type_e_SFF_MODULE_TYPE_10G_BASE_SRL: sff_module_type_e = 20;
pub const sff_module_type_e_SFF_MODULE_TYPE_1G_BASE_SX: sff_module_type_e = 21;
pub const sff_module_type_e_SFF_MODULE_TYPE_1G_BASE_LX: sff_module_type_e = 22;
pub const sff_module_type_e_SFF_MODULE_TYPE_1G_BASE_CX: sff_module_type_e = 23;
pub const sff_module_type_e_SFF_MODULE_TYPE_1G_BASE_T: sff_module_type_e = 24;
pub const sff_module_type_e_SFF_MODULE_TYPE_100_BASE_LX: sff_module_type_e = 25;
pub const sff_module_type_e_SFF_MODULE_TYPE_100_BASE_FX: sff_module_type_e = 26;
pub const sff_module_type_e_SFF_MODULE_TYPE_LAST: sff_module_type_e = 26;
pub const sff_module_type_e_SFF_MODULE_TYPE_COUNT: sff_module_type_e = 27;
pub const sff_module_type_e_SFF_MODULE_TYPE_INVALID: sff_module_type_e = -1;
#[doc = " sff_module_type"]
pub type sff_module_type_e = ::std::os::raw::c_int;
#[doc = " sff_module_type"]
pub use self::sff_module_type_e as sff_module_type_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn sff_module_type_name(e: sff_module_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn sff_module_type_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut sff_module_type_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn sff_module_type_desc(e: sff_module_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sff_module_type_map table."]
    pub static mut sff_module_type_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " sff_module_type_desc_map table."]
    pub static mut sff_module_type_desc_map: [aim_map_si_t; 0usize];
}
pub const sff_sfp_type_e_SFF_SFP_TYPE_SFP: sff_sfp_type_e = 0;
pub const sff_sfp_type_e_SFF_SFP_TYPE_QSFP: sff_sfp_type_e = 1;
pub const sff_sfp_type_e_SFF_SFP_TYPE_QSFP_PLUS: sff_sfp_type_e = 2;
pub const sff_sfp_type_e_SFF_SFP_TYPE_QSFP28: sff_sfp_type_e = 3;
pub const sff_sfp_type_e_SFF_SFP_TYPE_LAST: sff_sfp_type_e = 3;
pub const sff_sfp_type_e_SFF_SFP_TYPE_COUNT: sff_sfp_type_e = 4;
pub const sff_sfp_type_e_SFF_SFP_TYPE_INVALID: sff_sfp_type_e = -1;
#[doc = " sff_sfp_type"]
pub type sff_sfp_type_e = ::std::os::raw::c_int;
#[doc = " sff_sfp_type"]
pub use self::sff_sfp_type_e as sff_sfp_type_t;
extern "C" {
    #[doc = " Enum names."]
    pub fn sff_sfp_type_name(e: sff_sfp_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn sff_sfp_type_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut sff_sfp_type_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn sff_sfp_type_desc(e: sff_sfp_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sff_sfp_type_map table."]
    pub static mut sff_sfp_type_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " sff_sfp_type_desc_map table."]
    pub static mut sff_sfp_type_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " @brief Determine the SFP type (from the idprom data).\n @param idprom The SFF idprom."]
    pub fn sff_sfp_type_get(idprom: *const u8) -> sff_sfp_type_t;
}
extern "C" {
    #[doc = " @brief Determine the SFF module type (from the idprom data).\n @param idprom The SFF idprom."]
    pub fn sff_module_type_get(idprom: *const u8) -> sff_module_type_t;
}
extern "C" {
    #[doc = " @brief Determine the SFF Media type (from the idprom data)./\n @param idprom The SFF idprom."]
    pub fn sff_media_type_get(mt: sff_module_type_t) -> sff_media_type_t;
}
extern "C" {
    #[doc = " @brief Determine the SFF module capabilities (from the idprom data).\n @param idprom The SFF idprom.\n @param caps [out] Receives the capabilities.\n @returns 0 on successful parse.\n @returns < 0 on error."]
    pub fn sff_module_caps_get(mt: sff_module_type_t, caps: *mut u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sff_info_s {
    #[doc = " Vendor Name"]
    pub vendor: [::std::os::raw::c_char; 17usize],
    #[doc = " Model Number"]
    pub model: [::std::os::raw::c_char; 17usize],
    #[doc = " Serial Number"]
    pub serial: [::std::os::raw::c_char; 17usize],
    #[doc = " SFP Type"]
    pub sfp_type: sff_sfp_type_t,
    #[doc = " SFP Type Name"]
    pub sfp_type_name: *const ::std::os::raw::c_char,
    #[doc = " Module Type"]
    pub module_type: sff_module_type_t,
    #[doc = " Module Type Name"]
    pub module_type_name: *const ::std::os::raw::c_char,
    #[doc = " Media Type"]
    pub media_type: sff_media_type_t,
    #[doc = " Media Type Name"]
    pub media_type_name: *const ::std::os::raw::c_char,
    #[doc = " Capabilities"]
    pub caps: sff_module_caps_t,
    #[doc = " Cable length, if available"]
    pub length: ::std::os::raw::c_int,
    pub length_desc: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sff_info_s"][::std::mem::size_of::<sff_info_s>() - 120usize];
    ["Alignment of sff_info_s"][::std::mem::align_of::<sff_info_s>() - 8usize];
    ["Offset of field: sff_info_s::vendor"][::std::mem::offset_of!(sff_info_s, vendor) - 0usize];
    ["Offset of field: sff_info_s::model"][::std::mem::offset_of!(sff_info_s, model) - 17usize];
    ["Offset of field: sff_info_s::serial"][::std::mem::offset_of!(sff_info_s, serial) - 34usize];
    ["Offset of field: sff_info_s::sfp_type"]
        [::std::mem::offset_of!(sff_info_s, sfp_type) - 52usize];
    ["Offset of field: sff_info_s::sfp_type_name"]
        [::std::mem::offset_of!(sff_info_s, sfp_type_name) - 56usize];
    ["Offset of field: sff_info_s::module_type"]
        [::std::mem::offset_of!(sff_info_s, module_type) - 64usize];
    ["Offset of field: sff_info_s::module_type_name"]
        [::std::mem::offset_of!(sff_info_s, module_type_name) - 72usize];
    ["Offset of field: sff_info_s::media_type"]
        [::std::mem::offset_of!(sff_info_s, media_type) - 80usize];
    ["Offset of field: sff_info_s::media_type_name"]
        [::std::mem::offset_of!(sff_info_s, media_type_name) - 88usize];
    ["Offset of field: sff_info_s::caps"][::std::mem::offset_of!(sff_info_s, caps) - 96usize];
    ["Offset of field: sff_info_s::length"][::std::mem::offset_of!(sff_info_s, length) - 100usize];
    ["Offset of field: sff_info_s::length_desc"]
        [::std::mem::offset_of!(sff_info_s, length_desc) - 104usize];
};
pub type sff_info_t = sff_info_s;
#[doc = " SFF Module Information Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sff_eeprom_s {
    #[doc = " Raw eeprom data"]
    pub eeprom: [u8; 256usize],
    #[doc = " computed checksums for eeprom contents"]
    pub cc_base: u8,
    pub cc_ext: u8,
    #[doc = " Whether this EEPROM was successfully parsed and identified."]
    pub identified: ::std::os::raw::c_int,
    #[doc = " Parsed SFF Information"]
    pub info: sff_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sff_eeprom_s"][::std::mem::size_of::<sff_eeprom_s>() - 384usize];
    ["Alignment of sff_eeprom_s"][::std::mem::align_of::<sff_eeprom_s>() - 8usize];
    ["Offset of field: sff_eeprom_s::eeprom"]
        [::std::mem::offset_of!(sff_eeprom_s, eeprom) - 0usize];
    ["Offset of field: sff_eeprom_s::cc_base"]
        [::std::mem::offset_of!(sff_eeprom_s, cc_base) - 256usize];
    ["Offset of field: sff_eeprom_s::cc_ext"]
        [::std::mem::offset_of!(sff_eeprom_s, cc_ext) - 257usize];
    ["Offset of field: sff_eeprom_s::identified"]
        [::std::mem::offset_of!(sff_eeprom_s, identified) - 260usize];
    ["Offset of field: sff_eeprom_s::info"][::std::mem::offset_of!(sff_eeprom_s, info) - 264usize];
};
#[doc = " SFF Module Information Structure"]
pub type sff_eeprom_t = sff_eeprom_s;
extern "C" {
    #[doc = " @brief Initialize an SFF module information structure.\n @param rv [out] Receives the data.\n @param eeprom Raw EEPROM data.\n @note if eeprom is != NULL it will be copied into rv->eeprom first.\n @note if eeprom is NULL it is assumed the rv->eeprom buffer\n has already been initialized."]
    pub fn sff_eeprom_parse(rv: *mut sff_eeprom_t, eeprom: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize an SFF module information structure from a file.\n @param rv [out] Receives thh data.\n @param fname The filename."]
    pub fn sff_eeprom_parse_file(
        rv: *mut sff_eeprom_t,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Clear an sff_eeprom_t structure.\n @param eeprom The eeprom structure."]
    pub fn sff_eeprom_invalidate(info: *mut sff_eeprom_t);
}
extern "C" {
    #[doc = " @brief Determine if this is a valid SFP\n     (whether or not we can parse it)\n @param info The info structure.\n @param verbose Whether to report errors on invalid contents."]
    pub fn sff_eeprom_validate(
        info: *mut sff_eeprom_t,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Show an sff info structure.\n @param info The info structure.\n @param pvs The output pvs."]
    pub fn sff_info_show(info: *mut sff_info_t, pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " @brief Populate an SFF info structure from a module type."]
    pub fn sff_info_from_module_type(
        info: *mut sff_info_t,
        st: sff_sfp_type_t,
        mt: sff_module_type_t,
    ) -> ::std::os::raw::c_int;
}
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_RESET: onlp_sfp_control_e = 0;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_RESET_STATE: onlp_sfp_control_e = 1;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_RX_LOS: onlp_sfp_control_e = 2;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_TX_FAULT: onlp_sfp_control_e = 3;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_TX_DISABLE: onlp_sfp_control_e = 4;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_TX_DISABLE_CHANNEL: onlp_sfp_control_e = 5;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_LP_MODE: onlp_sfp_control_e = 6;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_SOFT_RATE_SELECT: onlp_sfp_control_e = 7;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_POWER_OVERRIDE: onlp_sfp_control_e = 8;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_LAST: onlp_sfp_control_e = 8;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_COUNT: onlp_sfp_control_e = 9;
pub const onlp_sfp_control_e_ONLP_SFP_CONTROL_INVALID: onlp_sfp_control_e = -1;
#[doc = " onlp_sfp_control"]
pub type onlp_sfp_control_e = ::std::os::raw::c_int;
#[doc = " onlp_sfp_control"]
pub use self::onlp_sfp_control_e as onlp_sfp_control_t;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_RESET: onlp_sfp_control_flag_e = 1;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_RESET_STATE: onlp_sfp_control_flag_e = 2;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_RX_LOS: onlp_sfp_control_flag_e = 4;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_TX_FAULT: onlp_sfp_control_flag_e = 8;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_TX_DISABLE: onlp_sfp_control_flag_e = 16;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_TX_DISABLE_CHANNEL:
    onlp_sfp_control_flag_e = 32;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_LP_MODE: onlp_sfp_control_flag_e = 64;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_SOFT_RATE_SELECT: onlp_sfp_control_flag_e =
    128;
pub const onlp_sfp_control_flag_e_ONLP_SFP_CONTROL_FLAG_POWER_OVERRIDE: onlp_sfp_control_flag_e =
    256;
#[doc = " onlp_sfp_control_flag"]
pub type onlp_sfp_control_flag_e = ::std::os::raw::c_uint;
#[doc = " onlp_sfp_control_flag"]
pub use self::onlp_sfp_control_flag_e as onlp_sfp_control_flag_t;
extern "C" {
    #[doc = " Initialize the SFP subsystem."]
    pub fn onlp_sfp_init() -> ::std::os::raw::c_int;
}
#[doc = " Valid SFP Port bitmaps are communicated using this type."]
pub type onlp_sfp_bitmap_t = aim_bitmap256_t;
extern "C" {
    #[doc = " Convenience function for initializing SFP bitmaps.\n @param bmap The address of the bitmap to initialize."]
    pub fn onlp_sfp_bitmap_t_init(bmap: *mut onlp_sfp_bitmap_t);
}
extern "C" {
    #[doc = " @brief Get the set of valid {Q}SFP ports.\n @param bmap Returns the valid set of SFP-capable port numbers."]
    pub fn onlp_sfp_bitmap_get(bmap: *mut onlp_sfp_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Determine if a given port number is a valid SFP port.\n @param port The port number."]
    pub fn onlp_sfp_port_valid(port: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Determine if an SFP is currently plugged in.\n @param port The SFP port number.\n @returns 1 if an SFP is present.\n @returns 0 if an SFP is not present.\n @returns <0 on error."]
    pub fn onlp_sfp_is_present(port: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the presence bitmap for all ports.\n @param dst The receives the presence bitmap for all ports.\n @note This function can return Unsupported.\n It will not be emulated if the SFPI driver does not support\n batch collection of the SFP presence."]
    pub fn onlp_sfp_presence_bitmap_get(dst: *mut onlp_sfp_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read IEEE standard EEPROM data from the given port.\n @param port The SFP Port\n @param rv Receives a buffer containing the EEPROM data.\n @notes The buffer must be freed after use.\n @returns The size of the eeprom data, if successful\n @returns -1 on error."]
    pub fn onlp_sfp_eeprom_read(
        port: ::std::os::raw::c_int,
        rv: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read the DOM data from the given port.\n @param port The SFP Port\n @param rv Receives a buffer containing the DOM data.\n @notes The buffer must be freed after use.\n @returns The size of the eeprom data, if successful\n @returns -1 on error.\n @note This should only be called if the SFP\n has advertised DOM support."]
    pub fn onlp_sfp_dom_read(
        port: ::std::os::raw::c_int,
        rv: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Deinitialize the SFP subsystem."]
    pub fn onlp_sfp_denit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the RX_LOS bitmap for all ports.\n @param dst Receives the RX_LOS bitmap for all ports.\n @note This function can return Unsupported.\n It will not be emulated if the SFPI driver does not support\n batch collection of the rx_los status."]
    pub fn onlp_sfp_rx_los_bitmap_get(dst: *mut onlp_sfp_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read a byte from an address on the given SFP port's bus.\n @param port The port number.\n @param devaddr The device address.\n @param addr The address."]
    pub fn onlp_sfp_dev_readb(
        port: ::std::os::raw::c_int,
        devaddr: u8,
        addr: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Write a byte to an address on the given SFP port's bus."]
    pub fn onlp_sfp_dev_writeb(
        port: ::std::os::raw::c_int,
        devaddr: u8,
        addr: u8,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read a byte from an address on the given SFP port's bus.\n @param port The port number.\n @param devaddr The device address.\n @param addr The address."]
    pub fn onlp_sfp_dev_readw(
        port: ::std::os::raw::c_int,
        devaddr: u8,
        addr: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Write a byte to an address on the given SFP port's bus."]
    pub fn onlp_sfp_dev_writew(
        port: ::std::os::raw::c_int,
        devaddr: u8,
        addr: u8,
        value: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Dump the status of all SFPs\n @param pvs The output pvs."]
    pub fn onlp_sfp_dump(pvs: *mut aim_pvs_t);
}
extern "C" {
    #[doc = " @brief Issue an ioctl to the SFP interface.\n @param port The port.\n @param ... Ioctl arguments."]
    pub fn onlp_sfp_ioctl(port: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Issue an ioctl to the SFP interface.\n @param port The port.\n @param vargs Ioctl arguments."]
    pub fn onlp_sfp_vioctl(
        port: ::std::os::raw::c_int,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Call the SFP post-insertion handler.\n"]
    pub fn onlp_sfp_post_insert(
        port: ::std::os::raw::c_int,
        info: *mut sff_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set an SFP control.\n @param port The port.\n @param control The control.\n @param value The value."]
    pub fn onlp_sfp_control_set(
        port: ::std::os::raw::c_int,
        control: onlp_sfp_control_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get an SFP control.\n @param port The port.\n @param control The control\n @param [out] value Receives the current value."]
    pub fn onlp_sfp_control_get(
        port: ::std::os::raw::c_int,
        control: onlp_sfp_control_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the value of all SFP controls.\n @param port The port.\n @param flags Receives the control flag values. See onlp_sfp_control_flags_t"]
    pub fn onlp_sfp_control_flags_get(
        port: ::std::os::raw::c_int,
        flags: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_sfp_control_name(e: onlp_sfp_control_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_sfp_control_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_sfp_control_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_sfp_control_desc(e: onlp_sfp_control_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " onlp_sfp_control_map table."]
    pub static mut onlp_sfp_control_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_sfp_control_desc_map table."]
    pub static mut onlp_sfp_control_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_sfp_control_flag_name(e: onlp_sfp_control_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_sfp_control_flag_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_sfp_control_flag_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_sfp_control_flag_desc(e: onlp_sfp_control_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_sfp_control_flag_valid(e: onlp_sfp_control_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_sfp_control_flag_map table."]
    pub static mut onlp_sfp_control_flag_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_sfp_control_flag_desc_map table."]
    pub static mut onlp_sfp_control_flag_desc_map: [aim_map_si_t; 0usize];
}
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_B2F: onlp_fan_caps_e = 1;
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_F2B: onlp_fan_caps_e = 2;
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_SET_RPM: onlp_fan_caps_e = 4;
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_SET_PERCENTAGE: onlp_fan_caps_e = 8;
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_GET_RPM: onlp_fan_caps_e = 16;
pub const onlp_fan_caps_e_ONLP_FAN_CAPS_GET_PERCENTAGE: onlp_fan_caps_e = 32;
#[doc = " onlp_fan_caps"]
pub type onlp_fan_caps_e = ::std::os::raw::c_uint;
#[doc = " onlp_fan_caps"]
pub use self::onlp_fan_caps_e as onlp_fan_caps_t;
pub const onlp_fan_dir_e_ONLP_FAN_DIR_B2F: onlp_fan_dir_e = 0;
pub const onlp_fan_dir_e_ONLP_FAN_DIR_F2B: onlp_fan_dir_e = 1;
pub const onlp_fan_dir_e_ONLP_FAN_DIR_LAST: onlp_fan_dir_e = 1;
pub const onlp_fan_dir_e_ONLP_FAN_DIR_COUNT: onlp_fan_dir_e = 2;
pub const onlp_fan_dir_e_ONLP_FAN_DIR_INVALID: onlp_fan_dir_e = -1;
#[doc = " onlp_fan_dir"]
pub type onlp_fan_dir_e = ::std::os::raw::c_int;
#[doc = " onlp_fan_dir"]
pub use self::onlp_fan_dir_e as onlp_fan_dir_t;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_OFF: onlp_fan_mode_e = 0;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_SLOW: onlp_fan_mode_e = 1;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_NORMAL: onlp_fan_mode_e = 2;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_FAST: onlp_fan_mode_e = 3;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_MAX: onlp_fan_mode_e = 4;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_LAST: onlp_fan_mode_e = 4;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_COUNT: onlp_fan_mode_e = 5;
pub const onlp_fan_mode_e_ONLP_FAN_MODE_INVALID: onlp_fan_mode_e = -1;
#[doc = " onlp_fan_mode"]
pub type onlp_fan_mode_e = ::std::os::raw::c_int;
#[doc = " onlp_fan_mode"]
pub use self::onlp_fan_mode_e as onlp_fan_mode_t;
pub const onlp_fan_status_e_ONLP_FAN_STATUS_PRESENT: onlp_fan_status_e = 1;
pub const onlp_fan_status_e_ONLP_FAN_STATUS_FAILED: onlp_fan_status_e = 2;
pub const onlp_fan_status_e_ONLP_FAN_STATUS_B2F: onlp_fan_status_e = 4;
pub const onlp_fan_status_e_ONLP_FAN_STATUS_F2B: onlp_fan_status_e = 8;
#[doc = " onlp_fan_status"]
pub type onlp_fan_status_e = ::std::os::raw::c_uint;
#[doc = " onlp_fan_status"]
pub use self::onlp_fan_status_e as onlp_fan_status_t;
#[doc = " Fan information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_fan_info_s {
    #[doc = " OID Header"]
    pub hdr: onlp_oid_hdr_t,
    pub status: u32,
    pub caps: u32,
    pub rpm: ::std::os::raw::c_int,
    pub percentage: ::std::os::raw::c_int,
    pub mode: onlp_fan_mode_t,
    pub model: [::std::os::raw::c_char; 64usize],
    pub serial: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_fan_info_s"][::std::mem::size_of::<onlp_fan_info_s>() - 796usize];
    ["Alignment of onlp_fan_info_s"][::std::mem::align_of::<onlp_fan_info_s>() - 4usize];
    ["Offset of field: onlp_fan_info_s::hdr"]
        [::std::mem::offset_of!(onlp_fan_info_s, hdr) - 0usize];
    ["Offset of field: onlp_fan_info_s::status"]
        [::std::mem::offset_of!(onlp_fan_info_s, status) - 648usize];
    ["Offset of field: onlp_fan_info_s::caps"]
        [::std::mem::offset_of!(onlp_fan_info_s, caps) - 652usize];
    ["Offset of field: onlp_fan_info_s::rpm"]
        [::std::mem::offset_of!(onlp_fan_info_s, rpm) - 656usize];
    ["Offset of field: onlp_fan_info_s::percentage"]
        [::std::mem::offset_of!(onlp_fan_info_s, percentage) - 660usize];
    ["Offset of field: onlp_fan_info_s::mode"]
        [::std::mem::offset_of!(onlp_fan_info_s, mode) - 664usize];
    ["Offset of field: onlp_fan_info_s::model"]
        [::std::mem::offset_of!(onlp_fan_info_s, model) - 668usize];
    ["Offset of field: onlp_fan_info_s::serial"]
        [::std::mem::offset_of!(onlp_fan_info_s, serial) - 732usize];
};
#[doc = " Fan information structure."]
pub type onlp_fan_info_t = onlp_fan_info_s;
extern "C" {
    #[doc = " @brief Initialize the fan subsystem."]
    pub fn onlp_fan_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve fan information.\n @param id The fan OID.\n @param rv [out] Receives the fan information."]
    pub fn onlp_fan_info_get(id: onlp_oid_t, rv: *mut onlp_fan_info_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the fan's operational status.\n @param id The fan OID.\n @param rv [out] Receives the fan's operations status flags.\n @notes Only operational state needs to be returned -\n        PRESENT/FAILED"]
    pub fn onlp_fan_status_get(id: onlp_oid_t, rv: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the fan's OID hdr.\n @param id The fan OID.\n @param rv [out] Receives the OID header."]
    pub fn onlp_fan_hdr_get(id: onlp_oid_t, hdr: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the fan speed in RPMs.\n @param id The fan OID.\n @param rpm The new RPM.\n @note Only valid if the fan has the SET_RPM capability."]
    pub fn onlp_fan_rpm_set(id: onlp_oid_t, rpm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the fan speed in percentage.\n @param id The fan OID.\n @param p The percentage.\n @note Only valid if the fan has the SET_PERCENTAGE capability."]
    pub fn onlp_fan_percentage_set(
        id: onlp_oid_t,
        p: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the fan speed by mode.\n @param id The fan OID.\n @param mode The fan mode value."]
    pub fn onlp_fan_mode_set(id: onlp_oid_t, mode: onlp_fan_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the fan direction.\n @param id The fan OID.\n @param dir The fan direction (B2F or F2B)\n @notes Only called if both capabilities are set."]
    pub fn onlp_fan_dir_set(id: onlp_oid_t, dir: onlp_fan_dir_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fan OID debug dump.\n @param id The fan OID.\n @param pvs The output pvs.\n @param flags The output flags."]
    pub fn onlp_fan_dump(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief Show the given Fan OID.\n @param id The Fan OID\n @param pvs The output pvs\n @param flags The output flags."]
    pub fn onlp_fan_show(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_fan_caps_name(e: onlp_fan_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_fan_caps_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_fan_caps_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_fan_caps_desc(e: onlp_fan_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_fan_caps_valid(e: onlp_fan_caps_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_fan_caps_map table."]
    pub static mut onlp_fan_caps_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_fan_caps_desc_map table."]
    pub static mut onlp_fan_caps_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_fan_dir_name(e: onlp_fan_dir_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_fan_dir_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_fan_dir_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_fan_dir_desc(e: onlp_fan_dir_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " onlp_fan_dir_map table."]
    pub static mut onlp_fan_dir_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_fan_dir_desc_map table."]
    pub static mut onlp_fan_dir_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_fan_mode_name(e: onlp_fan_mode_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_fan_mode_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_fan_mode_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_fan_mode_desc(e: onlp_fan_mode_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " onlp_fan_mode_map table."]
    pub static mut onlp_fan_mode_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_fan_mode_desc_map table."]
    pub static mut onlp_fan_mode_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_fan_status_name(e: onlp_fan_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_fan_status_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_fan_status_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_fan_status_desc(e: onlp_fan_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_fan_status_valid(e: onlp_fan_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_fan_status_map table."]
    pub static mut onlp_fan_status_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_fan_status_desc_map table."]
    pub static mut onlp_fan_status_desc_map: [aim_map_si_t; 0usize];
}
pub const onlp_led_caps_e_ONLP_LED_CAPS_ON_OFF: onlp_led_caps_e = 1;
pub const onlp_led_caps_e_ONLP_LED_CAPS_CHAR: onlp_led_caps_e = 2;
pub const onlp_led_caps_e_ONLP_LED_CAPS_RED: onlp_led_caps_e = 1024;
pub const onlp_led_caps_e_ONLP_LED_CAPS_RED_BLINKING: onlp_led_caps_e = 2048;
pub const onlp_led_caps_e_ONLP_LED_CAPS_ORANGE: onlp_led_caps_e = 4096;
pub const onlp_led_caps_e_ONLP_LED_CAPS_ORANGE_BLINKING: onlp_led_caps_e = 8192;
pub const onlp_led_caps_e_ONLP_LED_CAPS_YELLOW: onlp_led_caps_e = 16384;
pub const onlp_led_caps_e_ONLP_LED_CAPS_YELLOW_BLINKING: onlp_led_caps_e = 32768;
pub const onlp_led_caps_e_ONLP_LED_CAPS_GREEN: onlp_led_caps_e = 65536;
pub const onlp_led_caps_e_ONLP_LED_CAPS_GREEN_BLINKING: onlp_led_caps_e = 131072;
pub const onlp_led_caps_e_ONLP_LED_CAPS_BLUE: onlp_led_caps_e = 262144;
pub const onlp_led_caps_e_ONLP_LED_CAPS_BLUE_BLINKING: onlp_led_caps_e = 524288;
pub const onlp_led_caps_e_ONLP_LED_CAPS_PURPLE: onlp_led_caps_e = 1048576;
pub const onlp_led_caps_e_ONLP_LED_CAPS_PURPLE_BLINKING: onlp_led_caps_e = 2097152;
pub const onlp_led_caps_e_ONLP_LED_CAPS_AUTO: onlp_led_caps_e = 4194304;
pub const onlp_led_caps_e_ONLP_LED_CAPS_AUTO_BLINKING: onlp_led_caps_e = 8388608;
#[doc = " onlp_led_caps"]
pub type onlp_led_caps_e = ::std::os::raw::c_uint;
#[doc = " onlp_led_caps"]
pub use self::onlp_led_caps_e as onlp_led_caps_t;
pub const onlp_led_mode_e_ONLP_LED_MODE_OFF: onlp_led_mode_e = 0;
pub const onlp_led_mode_e_ONLP_LED_MODE_ON: onlp_led_mode_e = 1;
pub const onlp_led_mode_e_ONLP_LED_MODE_BLINKING: onlp_led_mode_e = 2;
pub const onlp_led_mode_e_ONLP_LED_MODE_RED: onlp_led_mode_e = 10;
pub const onlp_led_mode_e_ONLP_LED_MODE_RED_BLINKING: onlp_led_mode_e = 11;
pub const onlp_led_mode_e_ONLP_LED_MODE_ORANGE: onlp_led_mode_e = 12;
pub const onlp_led_mode_e_ONLP_LED_MODE_ORANGE_BLINKING: onlp_led_mode_e = 13;
pub const onlp_led_mode_e_ONLP_LED_MODE_YELLOW: onlp_led_mode_e = 14;
pub const onlp_led_mode_e_ONLP_LED_MODE_YELLOW_BLINKING: onlp_led_mode_e = 15;
pub const onlp_led_mode_e_ONLP_LED_MODE_GREEN: onlp_led_mode_e = 16;
pub const onlp_led_mode_e_ONLP_LED_MODE_GREEN_BLINKING: onlp_led_mode_e = 17;
pub const onlp_led_mode_e_ONLP_LED_MODE_BLUE: onlp_led_mode_e = 18;
pub const onlp_led_mode_e_ONLP_LED_MODE_BLUE_BLINKING: onlp_led_mode_e = 19;
pub const onlp_led_mode_e_ONLP_LED_MODE_PURPLE: onlp_led_mode_e = 20;
pub const onlp_led_mode_e_ONLP_LED_MODE_PURPLE_BLINKING: onlp_led_mode_e = 21;
pub const onlp_led_mode_e_ONLP_LED_MODE_AUTO: onlp_led_mode_e = 22;
pub const onlp_led_mode_e_ONLP_LED_MODE_AUTO_BLINKING: onlp_led_mode_e = 23;
#[doc = " onlp_led_mode"]
pub type onlp_led_mode_e = ::std::os::raw::c_uint;
#[doc = " onlp_led_mode"]
pub use self::onlp_led_mode_e as onlp_led_mode_t;
pub const onlp_led_status_e_ONLP_LED_STATUS_PRESENT: onlp_led_status_e = 1;
pub const onlp_led_status_e_ONLP_LED_STATUS_FAILED: onlp_led_status_e = 2;
pub const onlp_led_status_e_ONLP_LED_STATUS_ON: onlp_led_status_e = 4;
#[doc = " onlp_led_status"]
pub type onlp_led_status_e = ::std::os::raw::c_uint;
#[doc = " onlp_led_status"]
pub use self::onlp_led_status_e as onlp_led_status_t;
#[doc = " LED information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_led_info_s {
    #[doc = " Header"]
    pub hdr: onlp_oid_hdr_t,
    #[doc = " Status"]
    pub status: u32,
    #[doc = " Capabilities"]
    pub caps: u32,
    #[doc = " Current mode, if capable."]
    pub mode: onlp_led_mode_t,
    #[doc = " Current char, if capable."]
    pub character: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_led_info_s"][::std::mem::size_of::<onlp_led_info_s>() - 664usize];
    ["Alignment of onlp_led_info_s"][::std::mem::align_of::<onlp_led_info_s>() - 4usize];
    ["Offset of field: onlp_led_info_s::hdr"]
        [::std::mem::offset_of!(onlp_led_info_s, hdr) - 0usize];
    ["Offset of field: onlp_led_info_s::status"]
        [::std::mem::offset_of!(onlp_led_info_s, status) - 648usize];
    ["Offset of field: onlp_led_info_s::caps"]
        [::std::mem::offset_of!(onlp_led_info_s, caps) - 652usize];
    ["Offset of field: onlp_led_info_s::mode"]
        [::std::mem::offset_of!(onlp_led_info_s, mode) - 656usize];
    ["Offset of field: onlp_led_info_s::character"]
        [::std::mem::offset_of!(onlp_led_info_s, character) - 660usize];
};
#[doc = " LED information structure."]
pub type onlp_led_info_t = onlp_led_info_s;
extern "C" {
    #[doc = " @brief Initialize the LED subsystem."]
    pub fn onlp_led_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get LED information.\n @param id The LED OID\n @param rv [out] Receives the information structure."]
    pub fn onlp_led_info_get(id: onlp_oid_t, rv: *mut onlp_led_info_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the LED operational status.\n @param id The LED OID\n @param rv [out] Receives the operational status."]
    pub fn onlp_led_status_get(id: onlp_oid_t, rv: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the LED header.\n @param id The LED OID\n @param rv [out] Receives the header."]
    pub fn onlp_led_hdr_get(id: onlp_oid_t, rv: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Turn an LED on or off.\n @param id The LED OID\n @param on_or_off Led on (1) or LED off (0)\n @param Relevant if the LED has the ON_OFF capability.\n @note For the purposes of this function the\n interpretation of \"on\" for multi-mode or multi-color LEDs\n is up to the platform implementation."]
    pub fn onlp_led_set(id: onlp_oid_t, on_or_off: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the LED color\n @param id The LED OID\n @param color The color.\n @note Only relevant if the LED supports the color capability."]
    pub fn onlp_led_mode_set(id: onlp_oid_t, color: onlp_led_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the LED char\n @param id The LED OID\n @param c The character.\n @note Only relevant if the LED supports the char capability."]
    pub fn onlp_led_char_set(id: onlp_oid_t, c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief LED OID debug dump\n @param id The LED OID\n @param pvs The output pvs\n @param flags The output flags"]
    pub fn onlp_led_dump(oid: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief Show the given LED OID.\n @param id The LED OID\n @param pvs The output pvs\n @param flags The output flags"]
    pub fn onlp_led_show(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_led_caps_name(e: onlp_led_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_led_caps_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_led_caps_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_led_caps_desc(e: onlp_led_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_led_caps_valid(e: onlp_led_caps_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_led_caps_map table."]
    pub static mut onlp_led_caps_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_led_caps_desc_map table."]
    pub static mut onlp_led_caps_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_led_mode_name(e: onlp_led_mode_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_led_mode_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_led_mode_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_led_mode_desc(e: onlp_led_mode_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_led_mode_valid(e: onlp_led_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_led_mode_map table."]
    pub static mut onlp_led_mode_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_led_mode_desc_map table."]
    pub static mut onlp_led_mode_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_led_status_name(e: onlp_led_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_led_status_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_led_status_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_led_status_desc(e: onlp_led_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_led_status_valid(e: onlp_led_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_led_status_map table."]
    pub static mut onlp_led_status_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_led_status_desc_map table."]
    pub static mut onlp_led_status_desc_map: [aim_map_si_t; 0usize];
}
pub const onlp_thermal_caps_e_ONLP_THERMAL_CAPS_GET_TEMPERATURE: onlp_thermal_caps_e = 1;
pub const onlp_thermal_caps_e_ONLP_THERMAL_CAPS_GET_WARNING_THRESHOLD: onlp_thermal_caps_e = 2;
pub const onlp_thermal_caps_e_ONLP_THERMAL_CAPS_GET_ERROR_THRESHOLD: onlp_thermal_caps_e = 4;
pub const onlp_thermal_caps_e_ONLP_THERMAL_CAPS_GET_SHUTDOWN_THRESHOLD: onlp_thermal_caps_e = 8;
#[doc = " onlp_thermal_caps"]
pub type onlp_thermal_caps_e = ::std::os::raw::c_uint;
#[doc = " onlp_thermal_caps"]
pub use self::onlp_thermal_caps_e as onlp_thermal_caps_t;
pub const onlp_thermal_status_e_ONLP_THERMAL_STATUS_PRESENT: onlp_thermal_status_e = 1;
pub const onlp_thermal_status_e_ONLP_THERMAL_STATUS_FAILED: onlp_thermal_status_e = 2;
#[doc = " onlp_thermal_status"]
pub type onlp_thermal_status_e = ::std::os::raw::c_uint;
#[doc = " onlp_thermal_status"]
pub use self::onlp_thermal_status_e as onlp_thermal_status_t;
pub const onlp_thermal_threshold_e_ONLP_THERMAL_THRESHOLD_WARNING_DEFAULT:
    onlp_thermal_threshold_e = 45000;
pub const onlp_thermal_threshold_e_ONLP_THERMAL_THRESHOLD_ERROR_DEFAULT: onlp_thermal_threshold_e =
    55000;
pub const onlp_thermal_threshold_e_ONLP_THERMAL_THRESHOLD_SHUTDOWN_DEFAULT:
    onlp_thermal_threshold_e = 60000;
#[doc = " onlp_thermal_threshold"]
pub type onlp_thermal_threshold_e = ::std::os::raw::c_uint;
#[doc = " onlp_thermal_threshold"]
pub use self::onlp_thermal_threshold_e as onlp_thermal_threshold_t;
#[doc = " Thermal sensor information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_thermal_info_s {
    #[doc = " OID Header"]
    pub hdr: onlp_oid_hdr_t,
    #[doc = " Status"]
    pub status: u32,
    #[doc = " Capabilities"]
    pub caps: u32,
    pub mcelsius: ::std::os::raw::c_int,
    pub thresholds: onlp_thermal_info_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_thermal_info_s__bindgen_ty_1 {
    pub warning: ::std::os::raw::c_int,
    pub error: ::std::os::raw::c_int,
    pub shutdown: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_thermal_info_s__bindgen_ty_1"]
        [::std::mem::size_of::<onlp_thermal_info_s__bindgen_ty_1>() - 12usize];
    ["Alignment of onlp_thermal_info_s__bindgen_ty_1"]
        [::std::mem::align_of::<onlp_thermal_info_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: onlp_thermal_info_s__bindgen_ty_1::warning"]
        [::std::mem::offset_of!(onlp_thermal_info_s__bindgen_ty_1, warning) - 0usize];
    ["Offset of field: onlp_thermal_info_s__bindgen_ty_1::error"]
        [::std::mem::offset_of!(onlp_thermal_info_s__bindgen_ty_1, error) - 4usize];
    ["Offset of field: onlp_thermal_info_s__bindgen_ty_1::shutdown"]
        [::std::mem::offset_of!(onlp_thermal_info_s__bindgen_ty_1, shutdown) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_thermal_info_s"][::std::mem::size_of::<onlp_thermal_info_s>() - 672usize];
    ["Alignment of onlp_thermal_info_s"][::std::mem::align_of::<onlp_thermal_info_s>() - 4usize];
    ["Offset of field: onlp_thermal_info_s::hdr"]
        [::std::mem::offset_of!(onlp_thermal_info_s, hdr) - 0usize];
    ["Offset of field: onlp_thermal_info_s::status"]
        [::std::mem::offset_of!(onlp_thermal_info_s, status) - 648usize];
    ["Offset of field: onlp_thermal_info_s::caps"]
        [::std::mem::offset_of!(onlp_thermal_info_s, caps) - 652usize];
    ["Offset of field: onlp_thermal_info_s::mcelsius"]
        [::std::mem::offset_of!(onlp_thermal_info_s, mcelsius) - 656usize];
    ["Offset of field: onlp_thermal_info_s::thresholds"]
        [::std::mem::offset_of!(onlp_thermal_info_s, thresholds) - 660usize];
};
#[doc = " Thermal sensor information structure."]
pub type onlp_thermal_info_t = onlp_thermal_info_s;
extern "C" {
    #[doc = " @brief Initialize the thermal subsystem."]
    pub fn onlp_thermal_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve information about the given thermal id.\n @param id The thermal oid.\n @param rv [out] Receives the thermal information."]
    pub fn onlp_thermal_info_get(
        id: onlp_oid_t,
        rv: *mut onlp_thermal_info_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the thermal's operational status.\n @param id The thermal oid.\n @param rv [out] Receives the operational status."]
    pub fn onlp_thermal_status_get(id: onlp_oid_t, rv: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the thermal's oid header.\n @param id The thermal oid.\n @param rv [out] Receives the header."]
    pub fn onlp_thermal_hdr_get(id: onlp_oid_t, rv: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Thermal driver ioctl.\n @param code Thermal ioctl code.\n @param ... Arguments"]
    pub fn onlp_thermal_ioctl(code: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Thermal driver ioctl.\n @param code The thermal ioctl code.\n @param vargs The arguments."]
    pub fn onlp_thermal_vioctl(
        code: ::std::os::raw::c_int,
        vargs: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Thermal OID debug dump.\n @param id The thermal id.\n @param pvs The output pvs.\n @param flags The dump flags."]
    pub fn onlp_thermal_dump(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief Show the given thermal OID.\n @param id The Thermal OID\n @param pvs The output pvs\n @param flags The output flags"]
    pub fn onlp_thermal_show(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_thermal_caps_name(e: onlp_thermal_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_thermal_caps_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_thermal_caps_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_thermal_caps_desc(e: onlp_thermal_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_thermal_caps_valid(e: onlp_thermal_caps_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_thermal_caps_map table."]
    pub static mut onlp_thermal_caps_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_thermal_caps_desc_map table."]
    pub static mut onlp_thermal_caps_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_thermal_status_name(e: onlp_thermal_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_thermal_status_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_thermal_status_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_thermal_status_desc(e: onlp_thermal_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_thermal_status_valid(e: onlp_thermal_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_thermal_status_map table."]
    pub static mut onlp_thermal_status_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_thermal_status_desc_map table."]
    pub static mut onlp_thermal_status_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_thermal_threshold_name(
        e: onlp_thermal_threshold_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_thermal_threshold_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_thermal_threshold_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_thermal_threshold_desc(
        e: onlp_thermal_threshold_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_thermal_threshold_valid(e: onlp_thermal_threshold_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_thermal_threshold_map table."]
    pub static mut onlp_thermal_threshold_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_thermal_threshold_desc_map table."]
    pub static mut onlp_thermal_threshold_desc_map: [aim_map_si_t; 0usize];
}
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_AC: onlp_psu_caps_e = 1;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_DC12: onlp_psu_caps_e = 2;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_DC48: onlp_psu_caps_e = 4;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_VIN: onlp_psu_caps_e = 8;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_VOUT: onlp_psu_caps_e = 16;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_IIN: onlp_psu_caps_e = 32;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_IOUT: onlp_psu_caps_e = 64;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_PIN: onlp_psu_caps_e = 128;
pub const onlp_psu_caps_e_ONLP_PSU_CAPS_POUT: onlp_psu_caps_e = 256;
#[doc = " onlp_psu_caps"]
pub type onlp_psu_caps_e = ::std::os::raw::c_uint;
#[doc = " onlp_psu_caps"]
pub use self::onlp_psu_caps_e as onlp_psu_caps_t;
pub const onlp_psu_status_e_ONLP_PSU_STATUS_PRESENT: onlp_psu_status_e = 1;
pub const onlp_psu_status_e_ONLP_PSU_STATUS_FAILED: onlp_psu_status_e = 2;
pub const onlp_psu_status_e_ONLP_PSU_STATUS_UNPLUGGED: onlp_psu_status_e = 4;
#[doc = " onlp_psu_status"]
pub type onlp_psu_status_e = ::std::os::raw::c_uint;
#[doc = " onlp_psu_status"]
pub use self::onlp_psu_status_e as onlp_psu_status_t;
#[doc = " PSU Information Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct onlp_psu_info_t {
    #[doc = " OID Header"]
    pub hdr: onlp_oid_hdr_t,
    pub model: [::std::os::raw::c_char; 64usize],
    pub serial: [::std::os::raw::c_char; 64usize],
    pub status: u32,
    pub caps: u32,
    pub mvin: ::std::os::raw::c_int,
    pub mvout: ::std::os::raw::c_int,
    pub miin: ::std::os::raw::c_int,
    pub miout: ::std::os::raw::c_int,
    pub mpin: ::std::os::raw::c_int,
    pub mpout: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of onlp_psu_info_t"][::std::mem::size_of::<onlp_psu_info_t>() - 808usize];
    ["Alignment of onlp_psu_info_t"][::std::mem::align_of::<onlp_psu_info_t>() - 4usize];
    ["Offset of field: onlp_psu_info_t::hdr"]
        [::std::mem::offset_of!(onlp_psu_info_t, hdr) - 0usize];
    ["Offset of field: onlp_psu_info_t::model"]
        [::std::mem::offset_of!(onlp_psu_info_t, model) - 648usize];
    ["Offset of field: onlp_psu_info_t::serial"]
        [::std::mem::offset_of!(onlp_psu_info_t, serial) - 712usize];
    ["Offset of field: onlp_psu_info_t::status"]
        [::std::mem::offset_of!(onlp_psu_info_t, status) - 776usize];
    ["Offset of field: onlp_psu_info_t::caps"]
        [::std::mem::offset_of!(onlp_psu_info_t, caps) - 780usize];
    ["Offset of field: onlp_psu_info_t::mvin"]
        [::std::mem::offset_of!(onlp_psu_info_t, mvin) - 784usize];
    ["Offset of field: onlp_psu_info_t::mvout"]
        [::std::mem::offset_of!(onlp_psu_info_t, mvout) - 788usize];
    ["Offset of field: onlp_psu_info_t::miin"]
        [::std::mem::offset_of!(onlp_psu_info_t, miin) - 792usize];
    ["Offset of field: onlp_psu_info_t::miout"]
        [::std::mem::offset_of!(onlp_psu_info_t, miout) - 796usize];
    ["Offset of field: onlp_psu_info_t::mpin"]
        [::std::mem::offset_of!(onlp_psu_info_t, mpin) - 800usize];
    ["Offset of field: onlp_psu_info_t::mpout"]
        [::std::mem::offset_of!(onlp_psu_info_t, mpout) - 804usize];
};
extern "C" {
    #[doc = " @brief Initialize the PSU subsystem."]
    pub fn onlp_psu_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the PSU information.\n @param id The PSU OID.\n @param rv [out] Receives the information structure."]
    pub fn onlp_psu_info_get(id: onlp_oid_t, rv: *mut onlp_psu_info_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the PSU's operational status.\n @param id The PSU OID.\n @param rv [out] Receives the operational status."]
    pub fn onlp_psu_status_get(id: onlp_oid_t, rv: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the PSU's oid header.\n @param id The PSU OID.\n @param rv [out] Receives the header."]
    pub fn onlp_psu_hdr_get(id: onlp_oid_t, rv: *mut onlp_oid_hdr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Issue a PSU ioctl.\n @param id The PSU OID\n @param ... Ioctl arguments."]
    pub fn onlp_psu_ioctl(id: onlp_oid_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Issue a PSU ioctl.\n @param id The PSU OID\n @param vargs Ioctl arguments."]
    pub fn onlp_psu_vioctl(id: onlp_oid_t, vargs: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief PSU OID debug dump\n @param id The PSU OID\n @param pvs The output pvs\n @param flags The output flags"]
    pub fn onlp_psu_dump(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief Show the given PSU OID.\n @param id The PSU OID\n @param pvs The output pvs\n @param flags The output flags"]
    pub fn onlp_psu_show(id: onlp_oid_t, pvs: *mut aim_pvs_t, flags: u32);
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_psu_caps_name(e: onlp_psu_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_psu_caps_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_psu_caps_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_psu_caps_desc(e: onlp_psu_caps_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_psu_caps_valid(e: onlp_psu_caps_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_psu_caps_map table."]
    pub static mut onlp_psu_caps_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_psu_caps_desc_map table."]
    pub static mut onlp_psu_caps_desc_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " Enum names."]
    pub fn onlp_psu_status_name(e: onlp_psu_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum values."]
    pub fn onlp_psu_status_value(
        str_: *const ::std::os::raw::c_char,
        e: *mut onlp_psu_status_t,
        substr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enum descriptions."]
    pub fn onlp_psu_status_desc(e: onlp_psu_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enum validator."]
    pub fn onlp_psu_status_valid(e: onlp_psu_status_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " onlp_psu_status_map table."]
    pub static mut onlp_psu_status_map: [aim_map_si_t; 0usize];
}
extern "C" {
    #[doc = " onlp_psu_status_desc_map table."]
    pub static mut onlp_psu_status_desc_map: [aim_map_si_t; 0usize];
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
